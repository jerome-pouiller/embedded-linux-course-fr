% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Copyright 2010 Jérôme Pouiller <jezz@sysmic.org>
%

\part{Créer}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Booter par réseau}

\begin{frame}{Booter par réseau}
  \begin{itemize}
  \item Permet de travailler  plus confortablement car évite les cycles
    de scp/flash
  \item Parfois, il faut demarrer  la cible sous Linux pour pouvoir la
    flasher.  C'est donc la seule manière de continuer.
  \item Fonctionne aussi très bien avec des PC
  \item Trois étapes pour démarrer un système
    \begin{enumerate}
    \item Le bootloader configure la carte réseau et place le noyau en
      mémoire
    \item Le noyau s'exécute et monte un filesystem réseau
    \item Le premier processus de la vie du système est lancé: \cmd{init}
    \end{enumerate}
    \end{itemize}
\end{frame}

\subsection{Le bootloader}

\begin{frame}[fragile=singleslide]{Le bootloader}{Description}
  \begin{itemize}
  \item    Le    bootloader     se    trouve    souvent    sur    une
    \emph{eeprom}.  Celle-ci   est  directement  mappée   sur  le  bus
    d'adresse
  \item Au minimum, il doit initialiser:
    \begin{itemize}
    \item les timing de la mémoire RAM
    \item les caches CPU
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le bootloader}{Description}
  \begin{itemize}
  \item Il peut :
    \begin{itemize}
    \item Initialiser une ligne série pour l'utiliser comme terminal
    \item Offrir un prompt et accèder à des options de boot
    \item Initialiser la mémoire flash
    \item Copier le noyau en mémoire
    \item Passer des arguments au noyau
    \item Initialiser le chipset réseau
    \item  Récupérer  des  informations  provenant d'un  serveur  DHCP
      (serveur où récupérer l'image du noyau, indications sur les mise
      à jour disponibles, etc...)
    \item Lire des fichiers provenant du réseau
    \item Lire des fichiers par \verb+{X,Y,Z}MODEM+
    \item Ecrire sur la flash
    \item Gérer un système de secours
    \item  Initialiser des  fonctionnalités  cryptographiques (Trusted
      Plateform Manager)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Le bootloader}{Description}
  \begin{itemize}
    \item Il  est très  rare de pouvoir  démarrer Linux  sans bootloader
    fonctionnel
    \item Si votre bootloader  n'est pas fonctionnel, vous aurez souvent
    besoin d'un matériel particulier pour  le mettre à jour (un outil
    capable de flasher l'eeprom)
  \end{itemize}
  Bootloader connus:
  \begin{itemize}
    \item Grub
    \item Syslinux (et son dérivé Isolinux)
    \item U-Boot (utilisé ici)
    \item Redboot
    \item BareBox (successeur de U-Boot)
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Le bootloader}{Test}
  Testons notre bootloader:
  \begin{itemize}
    \item Démarrez minicom
    \begin{lstlisting}
host$ minicom -D /dev/ttyUSB0
    \end{lstlisting}
  \item Resettez la carte
  \item Appuyez sur une touche pour stopper le démarrage
    \begin{lstlisting}
[...]
Hit any key to stop autoboot:  0
    \end{lstlisting}
  \item Obtenez la liste des commandes
    \begin{lstlisting}
uboot> help
    \end{lstlisting}
  \item Attention aux caractères de contrôle (\cmd{<PgUp>}, \cmd{Ctrl+V}, ...)\\
%  \begin{itemize}
%  \item Pas d'historique
%  \item Pas de flèches gauche/droite
%  \end{itemize}
  \item En  cas de  problème pour  vous connecter,  vérifiez  vos paramètres
  RS232.
  \end{itemize}
\end{frame}

\subsection{TFTP}

\begin{frame}[fragile=singleslide]{TFTP}{Mise en place}
  \begin{itemize}
  \item Identique au protocole \cmd{ftp} mais plus simple
  \item Permet d'etre implémenté avec très peu de ressource
  \item Mise en place:
    \begin{lstlisting}
host% apt-get install tftp-hpa tftpd-hpa
host% cp hello/build-arm/hello /srv/tftp
    \end{lstlisting}
  \item Test en local
    \begin{itemize}
    \item Par le shell interactif
      \begin{lstlisting}
host$ tftp 127.0.0.1
> get hello
> quit
      \end{lstlisting}
    \item Par la ligne de commande
      \begin{lstlisting}
host$ tftp 127.0.0.1 -c get hello
      \end{lstlisting} % $
    \end{itemize}
    \note[item]{Il est possible de parler de inetd et /etc/default/atftpd}
  \item En cas de  problème, consultez les logs (\file{/var/log/syslog}
    ou \file{/var/log/daemon.log})
% A priori, ca n'est plus vrai avec les nouvelles version:
%     \item Remarque: chemin absolu, pas de cd, etc...
%       \begin{lstlisting}
% host$ scp root@target:/.../uImage /var/lib/tftpboot
% host$ atftp 127.0.0.1 -g -l /var/lib/tftpboot/uImage # Test
%       \end{lstlisting}
  % \item En  cas d'utilisation intensive (déploiement  sur des milliers
  %   de  systèmes),  vous   pouvez  utiliser  \cmd{atftpd}  de  manière
  %   autonome (voir \file{/etc/default/atftpd})
  % \item  Il  est  possible  de  modifier le  répertoire  partagé  dans
  %   \file{/etc/inetd.conf} ou dans \file{/etc/default/atftpd} (suivant
  %   le mode d'éxecution)
  %   \note[item]{Parler de inetd}
  \item  Il  est  possible  de  modifier le  répertoire  partagé  dans
    \file{/etc/default/tftpd-hpa}
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{TFTP}
  \note[item]{Il faut fournir le noyau pré-compilé ou le noyau Calao}
  Configuration de la cible pour télécharger et démarrer le noyau. Par RS232:
  \begin{itemize}
  \item Configuration de l'IP
    \begin{lstlisting}
uboot> setenv ipaddr 192.168.1.12
    \end{lstlisting}
  \item Vérification la configuration IP
    \note[item]{U-boot n'est  pas assez évolué pour  répondre aux ping
      (ca nécessite un service qui tourne en arrière plan ce qui n'est
      pas souhaitable pour faire du debug de bas niveau)}
    \begin{lstlisting}
uboot> ping 192.168.1.10
    \end{lstlisting}
  \item Déclaration de notre \emph{host} comme serveur \cmd{tftp}
    \begin{lstlisting}
uboot> setenv serverip 192.168.1.10
    \end{lstlisting}
    \note[item]{Eventuellement,   rebooter  après   le   saveenv  pour
      initialiser correctement le réseau}
 \item Nécésaire de passer la console au noyau:
    \begin{lstlisting}
uboot> setenv console console=ttyS0,115200
uboot> set bootargs ${console}
uboot> saveenv
    \end{lstlisting}
  \item Téléchargement du noyau dans une zone libre de la mémoire
    \note[item]{Expliquer d'où provient 21000000}
    \note[item]{L'adresse de  chargement du noyau  dépend de plusieurs
      parmètres: topologie  mémoire, utilisation  de la m'oire  par le
      bootloader, configuration du noyau, taille du noyau, etc..}
%    \note[item]{Reprendre   un    schéma   similaire   à    celui   de
%      \verb+http://www.at91.com/linux4sam/bin/view/Linux4SAM/GettingStarted#Linux4SAM_NandFlash_demo_Memory+
%      mais pour la RAM}
    \begin{lstlisting}
uboot> tftpboot 21000000 uImage
    \end{lstlisting}
  \item Exécution du noyau
    \begin{lstlisting}
uboot> bootm 21000000
    \end{lstlisting}
    \note[item]{Si autostart=yes, pas besoin de cette derniere ligne}
  \item Le noyau  trouve la flash, monte la flash  et charge l'init de
    la flash
    \note[item]{Exo: faites la même chose par ZMODEM}
    \note[item]{Tester avec le NFS éteind}
  \end{itemize}
\end{frame}

\subsection{NFS}

\begin{frame}[fragile=singleslide]{Nfs}
  Comparable au partage réseau de windows.
  \begin{itemize}
  \item Installation
    \begin{lstlisting}
host% apt-get install nfs-kernel-server nfs-common
host$ mkdir nfs
host% vim /etc/exports
    \end{lstlisting} % $
    \note[item]{nfs-common contient le client}
    \note[item]{On peut essayer avec unfs3}
    \note[item]{Autrefois le paquet s'apellait nfs-user-serveur}
  \item Configuration du partage
    \begin{lstlisting}
/home/user/nfs 0.0.0.0/0.0.0.0(rw,no_root_squash)
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Nfs}
  \begin{itemize}
    \item Test sur l'hôte
      \begin{lstlisting}
host% service nfs-kernel-server restart
host$ mkdir nfs-mount
host% mount -t nfs 127.0.0.1:/home/user/nfs nfs-mount
      \end{lstlisting} % $
    \item Vérification des droits root
      \begin{lstlisting}
host$ echo foo > nfs/file
host$ chmod 000 nfs/file
host$ ls -l nfs-mount
host% cat nfs-mount/file
      \end{lstlisting} % $
      \note[item]{ Le  test sur la cible  ne fonctionne que  si les binaires
        necessaires sont installée}
%     \item Test sur la cible (nécessite le support de NFS dans \cmd{mount})
%       \begin{lstlisting}
%target$ mkdir nfs-mount
%target% mount -t nfs 192.168.1.10:/home/user/nfs nfs-mount
%       \end{lstlisting} % $
     \item En cas de problème, vérifiez les logs: \file{/var/log/daemon.log}
   \end{itemize}
\end{frame}  

%    \note[item] {Ca permet de ne pas leur donner le rootfs. Est-ce qu'on garde?}
%    \note[item] {C'est une très mauvaise idée de dumper une partition montée}
%    \note[item] {Il faut mieux leur faire faire cette manip dans la section sur les MTD}
%     \item Obtenir une copie conforme de la cible
%       \begin{lstlisting}
% target% tar cv / | tftp host -p -l - -r /srv/tftp/root.tar
% host$ gzip /srv/tftp/root.tar
%       \end{lstlisting} % $
\begin{frame}[fragile=singleslide]{Démarrage sur le NFS}
  \begin{itemize}
  \item Modification des arguments passés au noyau
    \begin{itemize}
    \item Configuration IP
      \begin{lstlisting}
uboot> setenv ipconf ip=192.168.1.13::::::off
      \end{lstlisting}
    \item Configuration NFS
      \begin{lstlisting}
uboot> setenv nfsconf root=/dev/nfs nfsroot=192.168.1.10:/home/user/nfs
      \end{lstlisting}
    \item La variable \cmd{bootargs} permet de passer des arguments au noyau
      \begin{lstlisting}
uboot> setenv bootargs ${ipconf} ${nfsconf} ${console}
      \end{lstlisting}
    \item Démarrage
      \begin{lstlisting}
uboot> tftpboot 21000000 uImage
      \end{lstlisting}
    \end{itemize}
  \item Voir \file{Documentation/filesystem/nfs/nfsroot.txt}
  \item Après avoir monté le NFS, le noyau essaye de passer la main au
    programme \cmd{init}
  \end{itemize}
\end{frame}

\section{Compilation des differents éléments}

\subsection{Compilation du noyau}

\begin{frame}[fragile=singleslide]{Récupération des sources}
  Où récupérer les sources du noyau?
  \begin{enumerate}
  \item Utiliser  les sources souvent fournies.  Il arrive souvent
    qu'elles  contiennent  des  drivers particuliers  et  qu'elles
    soient déjà configurées
  \item Utiliser \cmd{git clone} (nous y reviendrons)
  \item Télecharger sur \file{kernel.org}
  \end{enumerate}
  \note[item]{Fonctionne aussi avec 2.6.37}
  \begin{lstlisting}
host$ wget http://www.kernel.org/pub/linux/kernel/v3.X/linux-3.5.7.tar.bz2
host$ tar xvjf linux-3.5.7.tar.bz2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Interface de configuration du noyau}
  \begin{itemize}
    \item Utilise Kconfig
      \begin{lstlisting}
host$ make help
host$ mkdir build
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- menuconfig
       \end{lstlisting}
     \item  Beaucoup d'options,  mais il  y a  l'aide (\verb+<h>+)  et la
       recherche (\verb+</>+)
    \item La configuration est sauvée dans \file{.config}
    \item    \verb+usb-a9260_defconfig+   permet   de    charger   une
      configuration pré-établie pour notre carte
      \begin{lstlisting}
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- usb-a9260_defconfig
      \end{lstlisting}
    \begin{itemize}
    \item Certains constructeur vous  fournirons un patch ajoutant une
      cible \verb+_defconfig+
    \item D'autres vous fournirons un \file{.config}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation du noyau}
  \begin{itemize}
  \item Vérifier les options du type de processeur
  \item Cocher NFS
  \item Le reste ne devrait pas empêcher de démarrer votre cible
  \item La compilation se lance avec
    \begin{lstlisting}
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- XXImage
    \end{lstlisting}
  \item \verb+XX+ fait référence au format de la binaire produite:
    \begin{itemize}
    \item Le premier octet est-il du code?
    \item Respecte-t-il le format ELF?
    \item Y a-t-il un format particulier d'entête à respecter ?
    \end{itemize}
  \item Dans  le doute,  il faut consulter  la documentation  de votre
    bootloader
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Compiler le noyau}
  Dans notre cas, nous utilisons U-Boot (standard)
  \begin{itemize}
  \item Compilation
    \begin{lstlisting}
host% apt-get install uboot-mkimage
host$ make O=build ARCH=arm CROSS_COMPILE=arm-linux- uImage
    \end{lstlisting}
  \item Partage de l'image par TFTP
    \begin{lstlisting}
host% cp build/arch/arm/boot/uImage /srv/tftp/uImage-3.5.7
host% ln -s uImage-3.5.7 /srv/tftp/uImage
    \end{lstlisting} % $ 
  \item  Au   redémarrage,  le   bootloader  passe  par   un  registre
    l'identifiant  de   la  carte.   Cet   identifiant  (spécifique  à
    l'architecture ARM) est erroné. A  ce stade, il est plus facile de
    corriger   ce   problème   dans   le   noyau   dans   le   fichier
    \file{arch/arm/tools/mach-types}.
    \note[item]{C'est mieux de compiler avec -j3}
    \note[item]{Il faut les laisser démarrer en NFS}
    \note[item]{Il faut  commenter la ligne  1108 et changer  la ligne
      1700}
  \end{itemize}
  \note{Parler de l'installation des modules et de l'option INSTALL\_MOD\_PATH}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation du noyau}
  Fichiers produits (ou productibles) par la compilation:
  \begin{itemize}
  \item  \verb+vmlinux+:  L'image  ELF  du  noyau.   Lisible  par  les
    debugueurs, certains flasheurs, certains bootloaders
  \item  \verb+vmlinuz+: parfois  équivalent  du \verb+bzImage+,  mais
    normalement, il  s'agit de\verb+vmlinux+ compressé  et strippé des
    informations inutiles  au démarrage. Inutilisable  dans l'état, il
    est nécessaire de lui adjoindre un bootloader pour le décompresser
    et l'exécuter.
  \item  \verb+Image+:  \verb+vmlinux+   strippé  et  préfixé  par  un
    mini-bootloader   permettant    de   sauter   sur    la   fonction
    \verb+start_kernel+ de \verb+vmlinux+.
  \item  \verb+bzImage+  et   \verb+zImage+:  \verb+vmlinuz+  avec  le
    bootloader \cmd{bz2} ou \cmd{gz}.
  \item  \verb+xipImage+  :  Idem  \verb+Image+ mais  destiné  à  être
    exécuté  directement  sur un  \emph{eeprom}  sans  être copier  en
    mémoire au préalable.
  \item  \verb+uImage+:  \verb+Image+ avec  une  entête spéciale  pour
    \emph{u-boot}.
  \end{itemize}
%   Il est possible  de générer des image au  format SRecord en utiliant
%   \cmd{objcopy}
%   \begin{lstlisting}
% host$ objcopy -O srec vmlinux vmlinux.srec
%    \end{lstlisting}
  \note[item]{Reprendre le  slide de freeelectron très  bien foutu sur
    le sujet}
\end{frame}

\begin{frame}[fragile=singleslide]{Les modules}
Deux mots sur les modules:
  \begin{itemize}
  \item Morceaux de noyaux externalisés
  \item Compilation avec \cmd{make [...] modules}
  \item Installation avec \cmd{make [...] INSTALL_MOD_PATH=~/rootfs modules_install}
  \end{itemize}
\end{frame}

\subsection{Création de l'init}

\begin{frame}[fragile=singleslide]{Démarrage du noyau}
  \begin{itemize}
  \item A  la fin du  démarrage du noyau, ce  dernier donne la  main à
    l'exécutable déclaré  avec \verb+init=+. Par défaut,  il s'agit de
    \file{/sbin/init}
  \item \cmd{init} ne se termine jamais
  \item  Les  arguments  non-utilisés  par le  noyau  sont  passés  à
    \cmd{init}
  \item On peut  estimer que notre système démarre  à partir du moment
    ou nous obtenons un shell (c'est en tous cas là que la plupart des
    intégrateurs Linux embarqué s'arrêteront)
  \item Du moins complexe au plus complexe à démarrer:
  \begin{itemize}
    \item \verb+init=/hello-arm-static+
    \item \verb+init=/hello-arm+
    \item \verb+init=/bin/sh+
    \item \verb+init=/sbin/init+
    \end{itemize}
  \end{itemize}
  Effectuons ces tests avec le Rootfs original et un Rootfs vierge.
\end{frame}

\begin{frame}[fragile=singleslide]{Créer l'espace utilisateur}{Créer l'arborescence}
  Nous travaillerons dans un répertoire vierge
  \begin{lstlisting}
host$ mkdir nfs-root-mine
host$ ln -s nfs-root-mine nfs
host$ cd nfs-root-mine
  \end{lstlisting} % $
  L'arborescence classique sera:
  \vspace{-2ex}
  \begin{columns}[onlytextwidth,t]
    \begin{column}[t]{0.5\textwidth}
      \begin{itemize}
      \item bin
      \item sbin
      \item usr/bin
      \item usr/sbin
      \item etc
      \end{itemize}
    \end{column}
    \begin{column}[t]{0.5\textwidth}
      \begin{itemize}
      \item dev
      \item proc
      \item sys
      \item tmp
      \item var
      \end{itemize}
    \end{column}
  \end{columns}
  \vspace{2ex}
  Il est possible de ne pas respecter cette arborescence, mais cela
  compliquerait inutilement la chose
\end{frame}

\begin{frame}[fragile=singleslide]{Créer l'espace utilisateur}{Créer l'arborescence}
  Après le démarrage, le noyau ne trouve pas l'init:
    \begin{lstlisting}
[...]
Kernel panic - not syncing: No init found.  Try passing init= option to kernel.
    \end{lstlisting}

    Copions maintenant  \verb+hello-arm-static+ et \verb+hello-arm+ et
    essayons de démarrer avec.
\end{frame}


\begin{frame}[fragile=singleslide]{Installation des bibliothèques de base}
  Les bibliothèques de base  (\cmd{libc} et apparentés) sont forcement
  fournies avec le cross-compilateur, car elles y sont intimement liées
  \begin{itemize}
  \item Liste des bibliothèques nécessaires
    \begin{lstlisting}
host$ arm-linux-ldd --root . hello-arm
    \end{lstlisting}
    \item Copie
    \begin{lstlisting}
host$ mkdir lib
host$ cp /opt/arm-linux-.../lib/ld-uClibc-0.9.30.2.so lib
host$ cp /opt/arm-linux-.../lib/libuClibc-0.9.30.2.so lib
    \end{lstlisting}
  \end{itemize}
\end{frame}  

\begin{frame}[fragile=singleslide]{Installation des bibliothèques de base}
  \begin{itemize}
  \item Configuration de \cmd{ldconfig}
    \begin{lstlisting}
host$ echo /lib > etc/ld.so.conf
host$ echo /usr/lib >> etc/ld.so.conf
    \end{lstlisting}
  \item Création des liens symboliques
    \begin{lstlisting}
host$ ldconfig -r . -N
    \end{lstlisting}
  \item Création du cache. Le  cache n'est pas obligatoire, mais si il
    existe, il doit être à jour
    \note[item]{Faire un exo sur PC avec ldconfig}
    \begin{lstlisting}
host$ ldconfig -r .
    \end{lstlisting}
  \end{itemize}
  Nous pouvons maintenant démarrer avec \verb+init=/hello-arm+
\end{frame}

\subsection{Compilation de l'espace utilisateur}

\begin{frame}[fragile=singleslide]{Busybox}
  \begin{itemize}
  \item  Contient la plupart  des binaires  nécessaires pour  démarrer un
    système
  \item Attention, ce ne  sont pas les mêmes outils que sur  PC. Il y a
    souvent des options non-implémentées ou des comportements différents
  \item Téléchargement
    \begin{lstlisting}
host$ wget http://busybox.net/downloads/busybox-1.19.4.tar.bz2
host$ tar xvjf busybox-1.19.4.tar.bz2
host$ mkdir build
    \end{lstlisting}
  \item On retrouve \cmd{Kconfig}
    \begin{lstlisting}
host$ make O=build CROSS_COMPILE=arm-linux- allnoconfig
host$ make O=build CROSS_COMPILE=arm-linux- menuconfig
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Busybox}
  \begin{itemize}
  \item On trouve plein d'outils
    \note[item]{TODO: mettre en plusieurs colonnes}
  \item    Au   minimum,    vérifions les options    \cmd{ash},   \cmd{init},    les
    \emph{Coreutils},   
    %\cmd{dmesg},   \cmd{ifconfig},   \cmd{mount},
    %\cmd{tftp}, \cmd{tar}, \cmd{reboot}, \cmd{vi}, \cmd{flashcp}
    \note[item]{TODO: mettre en plusieurs colonnes}
  \item         Et         aussi:        \verb+CONFIG_PLATFORM_LINUX+,
    \verb+CONFIG_FEATURE_EDITING+,        \verb+CONFIG_FEATURE_DEVPTS+,
    \verb+CONFIG_LONG_OPTS+,                  \verb+CONFIG_SHOW_USAGE+,
    \verb+FEATURE_VERBOSE_CP_MESSAGE+, \verb+IOCTL_HEX2STR_ERROR+
  \end{itemize}
  \note[item]{TODO P2 Lister de manière exhaustive}
\end{frame}

\begin{frame}[fragile=singleslide]{Installation de Busybox}
  \begin{itemize}
  \item Configurons le chemin de destination vers \file{\~/nfs}
    \begin{lstlisting}
host$ make O=build CROSS_COMPILE=arm-linux-
host$ make O=build CROSS_COMPILE=arm-linux- install
    \end{lstlisting}
    \note[item]{Compiler avec -j3}
  \item  L'installation créé  des  liens symboliques  vers la  binaire
    \cmd{busybox}
  \item  Sans  Busybox,  toutes  ces  binaires  seraient  séparées  et
    dispersées sur une dizaine de sources
  \item Nous pouvons maintenant démarrer avec \verb+init=/bin/sh+
    \note[item] {Démarrer avec  console=ttyS0,115200 afin d'éviter les
      problème avec le jobs: Non ca ne marche pas}
  \item \verb+init=/sbin/init+ pose encore quelques problèmes.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Configuration de \cmd{init}}
  Il est possible de configurer \cmd{init} avec le fichier
  \file{/etc/inittab}
  \begin{itemize}
  \item Lancement automatique d'un shell
    \begin{lstlisting}
host$ echo 'ttyS0::askfirst:/bin/sh' > etc/inittab 
    \end{lstlisting}
  \item Appel d'un script de démarrage.
    \begin{lstlisting}
host$ echo '::sysinit:/etc/init.d/rcS' >> etc/inittab 
host$ mkdir etc/init.d
host$ echo '#!/bin/sh' > etc/init.d/rcS
host$ chmod +x etc/init.d/rcS
    \end{lstlisting}
  \end{itemize}
  Documentation disponible sur la page de man \emph{inittab(5)}
  (disponible ici: \url{http://tfm.cz/man/5/inittab}).\\[2ex]
  Des  fichiers de  configuration  de init  et  d'autres utilitaires  de
  busybox sont disponibles dans \file{busybox/examples}
  \note[item]{tester  avec console=ttyS0,115200  et retirer  "ttyS0 de
    l'inittab": Non ca ne marche pas}
\end{frame}

\begin{frame}[fragile=singleslide]{Démarrage d'une binaire statique}
  Les fichiers devices
  \begin{itemize}
  \item Permettent de communiquer avec le noyau
  \item Il représente plus ou moins chacun un périphérique
  \item       Les       plus        importants       sont       normés
    (\file{Documentation/devices.txt})
  \item Il est possible de les créer avec \cmd{mknod}:
    \begin{lstlisting}
host% mknod dev/console c 5 1
    \end{lstlisting}
%  \item  Ce  device  est  nécessaire  pour  \cmd{printf}.   Il  serait
%    possible  d'écrire un programme  ne nécessitant  aucun accès  à un
%    périphérique (exemple: le service réseau echo)
  \end{itemize}
%  Nous pouvons maintenant démarrer avec \verb+init=/hello-arm-static+
\end{frame}

\begin{frame}[fragile=singleslide]{Compilons init}{Fichiers devices}
  Ajoutons  les devices  \file{/dev/tty}  (En fait,  pas  tout à  fait
  obligatoire)
  \begin{lstlisting}
host% mknod dev/ttyS0 c 4 64
host% mknod dev/tty2 c 4 2
host% mknod dev/tty3 c 4 3
host% mknod dev/tty4 c 4 4
  \end{lstlisting}
  \note[item]{tester  avec console=ttyS0,115200  et retirer  cette section : Non, ca ne marche pas}
%   \item \cmd{MAKEDEV} automatise une partie de la création des fichiers
%     devices
%     \note[item]{TODO Voir si on ne  peut pas continuer sans MAKEDEV et
%       l'introduire dans la section "Ajouts"}
%     \begin{lstlisting}
% host% cd dev
% host% MAKEDEV std
% host% MAKEDEV console
%     \end{lstlisting}
  Nous  pouvons  maintenant  démarrer avec  \cmd{init=/bin/init}  mais
  certaines fonctionnalités sont absentes (\cmd{ps}, etc... )
\end{frame}


\begin{frame}[fragile=singleslide]{Compilons init}{Fichiers de configuration}
  Il faut monter les partitions \cmd{/proc} et \cmd{/sys}:
  \begin{lstlisting}
target% mount -t proc none /proc 
target% mount -t sysfs none /sys
  \end{lstlisting}
  Automatisation du montage avec \file{inittab}:
  \begin{lstlisting}
host$ echo "::sysinit:mount -t proc none /proc" >> etc/inittab 
host$ echo "::sysinit:mount -t sysfs none /sys" >> etc/inittab 
  \end{lstlisting}
  Nos commandes semblent maintenant correctement fonctionner.
\end{frame}

\begin{frame}[fragile=singleslide]{Autres \cmd{init}}
  Il existe d'autres formes d'\cmd{init}:
  \begin{itemize}
  \item SystemV (celui que nous utilisons)
  \item runit (aussi proposé par Busybox)
  \item upstart (utilisé par Ubuntu)
  \end{itemize}
  Ces \cmd{init},  plus modernes  offrent de nouvelles  fonctionnalités et
  plus de robustesse pour le système.
\end{frame}

\begin{frame}{Et si ca ne marche toujours pas?}
  \begin{itemize}
  \item Toujours commencer par  \emph{hello-static}, le moins dépendant
  \item Si il ne fonctionne  pas, recherchez du coté du format de binaire
    de  la chaîne  de compilation  et avec  sa compatibilité  avec les
    options du noyaux
  \item  Si \emph{hello-static} fonctionne,  mais pas  \emph{hello} en
    dynamique, cherchez du coté du format de la \emph{libc} et de
    sa compatibilité avec le format de binaire de \emph{hello}
  \item Si \emph{hello} fonctionne mais  que vous ne pouvez pas lancer
    de shell, cherchez du coté des devices et des droits.
  \item Si le  shell démarre mais pas init, rechechez  du coté des
    fichiers de configuration et des devices
  \item Vérifier que votre cible  ne change pas d'IP en démarrant (ici
    dans \file{/etc/inittab})
  \item Sinon, cherchez dans les parametres passés au noyau ou dans la
    configuration
  \item Si possible, toujours tester entre chaque modification
  \end{itemize}
\end{frame}

\begin{frame}{Résumé}
  Que contient l'espace utilisateur standard?
  \begin{itemize}
  \item une arborescence
  \item des binaires
  \item des bibliothèques
  \item des fichiers devices
  \end{itemize}
\end{frame}

\section{Quelques ajouts}
 
\begin{frame}[fragile=singleslide]{Utilisation de \file{fstab}}
  Il  est   possible  d'automatiser  ce  montage   au  démarrage  avec
  \file{fstab} et \cmd{mount -a}
  \begin{lstlisting}
host$ echo 'none /proc proc'  >> etc/fstab
host$ echo 'none /sys  sysfs' >> etc/fstab
target% mount -a
  \end{lstlisting}

  Nous pouvons utiliser le  fichier \file{etc/inittab} pour monter nos
  partitions automatiquement.
  \begin{lstlisting}
host$ echo "::sysinit:/bin/mount -a" >> etc/inittab 
host$ echo "::shutdown:/bin/mount -r -a" >> etc/inittab 
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Filesystem temporaire}
  Créer un  filesystem en  mémoire permet de  protéger notre  flash (à
  durée  de vie  limitée), de  garantir que  nos systèmes  seront toujours
  identiques entre chaque démarrage et d'améliorer les performances.
  \begin{itemize}
    \item Création
    \begin{lstlisting}
host$ mkdir tmp
    \end{lstlisting}
  \item Ajout du \emph{stickybit} comme il se doit
    \begin{lstlisting}
host$ chmod +t tmp
    \end{lstlisting}
  \item Montage d'un filesystem contenu en mémoire
    \begin{lstlisting}
target% mount -t tmpfs none tmp
host$ echo 'none /tmp tmpfs' >> etc/fstab
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Utilisation de \cmd{MAKEDEV}}
  \cmd{MAKEDEV} permet d'automatiser  la création des fichiers devices
  de base
  \begin{lstlisting}
host$ cd dev
host$ MAKEDEV std
host$ MAKEDEV console
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Peudo Terminal Multiplexer}
  \cmd{ptmx} (Peudo  Terminal Multiplexer) Permet  de facilement gérer
  l'allocation des terminaux. (Nécessaire pour Dropbear)
  \begin{lstlisting}
host% mknod dev/ptmx c 5 2
host$ mkdir dev/pts
host$ echo 'none /dev/pts devpts' >> etc/fstab
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Utilisation de \cmd{mdev}}
  \begin{itemize}
  \item Intégré dans Busybox
  \item Uniquement depuis 2.6, nécessite \file{/sys} compilé et monté
  \item Permet de créer les devices à la volée
  \item Sur  les systèmes  très petits et  où l'utilisation  de device
    dynamique n'est  pas nécessaire, onse passe de  \cmd{mdev} à cause
    des dépendances avec le noyau
  \item Création de \file{/dev} sur un disque mémoire
    \begin{lstlisting}
target% mount -t tmpfs none /dev
    \end{lstlisting}
  \item Initialisation \file{/dev} lors du démarrage
    \begin{lstlisting}
target% mdev -s
    \end{lstlisting}
  \item  Installation  de  \cmd{mdev}  comme \emph{handler}  pour  les
    nouveaux périphériques
    \begin{lstlisting}
target% echo /sbin/mdev > /proc/sys/kernel/hotplug
    \end{lstlisting}
    \note[item]{Brancher une clef USB pour faire la démonstration}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Utilisation de \cmd{mdev}}
  \begin{itemize}
  \item  Automatisation du processus
    \begin{lstlisting}
host$ echo 'none /dev tmpfs' >> etc/fstab
host$ echo "mdev -s" >> etc/rcS
host$ echo "echo /sbin/mdev > /sys/kernel/uevent_helper" >> etc/rcS
    \end{lstlisting}
  \item Il est aussi possible d'utiliser devtmpfs
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Résolution DNS}
  \begin{itemize}
  \item Ajout de la résolution DNS
    \begin{lstlisting}
host$ echo nameserver 8.8.8.8 > etc/resolv.conf
target% ping www.google.com
    \end{lstlisting}
  \item  Si nous Utilisions la  \emph{glibc}  au lieu  de  la \emph{uclibc},  il
    serait    alors    nécessaire    de    configurer    le    fichier
    \file{nsswitch.conf}.   Il  serait   possible  de   choisir  parmi
    différents  backends  pour  gérer  les  authentifications  et  le
    réseau.
  \item  Le reste  de la  configuration réseau  s'effectue normalement
    dans \file{/etc/network}
    \item Pour utiliser le dhcp, ne pas oublier de recopier le fichier 
    \cmd{examples/udhcp/simple.script} fourni avec busybox vers 
    \cmd{/usr/share/udhcpc/default.script}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Ajouts d'utilisateurs}
  \begin{itemize}
  \item Ajout d'utilisateurs  (nécessaire pour beaucoup d'applications
    dont Dropbear)
    \begin{lstlisting}
host$ echo 'root:x:0:0:root:/root:/bin/sh' > etc/passwd
host$ echo 'root:x:0:' > etc/group
host$ echo "::sysinit:login" >> etc/inittab 
    \end{lstlisting}
  \item  \verb'root::0:0:root:/root:/bin/sh'  créerait un  utilisateur
    sans mot de passe
    \item Possibilité de calculer les mots de passe avec \cmd{mkpasswd}. Voir \cmd{mkpasswd -m help}
    \item Possibilité de gérer les mots de passe dans \cmd{/etc/shadow} (\man{shadow(5)}) pour plus de sécurité:
    \begin{lstlisting}
host$ echo 'root:x:::::::' > etc/shadow
    \end{lstlisting}
    \note[item]{TODO: Parler de shadow, mkpasswd}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Dropbear}
  \begin{itemize}
  \item Serveur et client ssh
  \item Procédure classique (ou presque, cf. \cmd{INSTALL})
    \begin{lstlisting}
host$ wget http://matt.ucc.asn.au/dropbear/releases/dropbear-0.53.tar.bz2
host$ tar xvjf dropbear-0.53.tar.bz2
host$ cd dropbear; mkdir build; cd build
host$ ../configure --disable-zlib --host=arm-linux --build=i386 --prefix=$(pwd)/../install
host$ make PROGRAMS="dropbear dbclient dropbearkey dropbearconvert scp"
host$ make install
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Dropbear}
  \begin{itemize}
  \item Gestion des clefs autorisées
    \begin{lstlisting}
host$ mkdir -p etc/dropbear
host$ mkdir -p root/.ssh
host$ cat ~/.ssh/id_dsa.pub >> root/.ssh/authorized_keys
    \end{lstlisting}%$
  \item Génération des clefs host:
    \begin{lstlisting}
target% dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key
target% dropbearkey -t dss -f /etc/dropbear/dropbear_dss_host_key
target% dropbear -E
host$ echo "ttyS0::respawn:/sbin/dropbear -EF" >> etc/inittab
host$ ssh root@target
    \end{lstlisting}
  \end{itemize}
  Dropbear  nécessite un  certain  nombre de  fonctionnalités de  notre
  Linux.  Le faire  fonctionner est  un bon  test de  compatibilité de
  notre système
\end{frame}

\section{Bootstrapper la toolchain}

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  \begin{itemize}
  \item Le compilateur et la \cmd{libc} se compilent ensemble
  \item On peut identifier la toolchain à son triplet:
    \begin{itemize}
    \item \verb+<CPU>-<VENDOR>-<SYSTEM>+
    \item \verb+<SYSTEM> ~ <KERNEL>-<OS>+
    \item \verb+<KERNEL> =+ linux
    \item \verb+<OS>+  est une notion  plus floue: gnu,  ulibc, glibc,
      ulibcgnueabi...
    \end{itemize}
  \item  Pour \cmd{gcc},  on abbrège  souvent le  triplet  en omettant
    \verb+<VENDOR>+
  \item Exemples: 
    \begin{itemize}
    \item ppc85-e8541-linux-gnu % A verfieir
    \item arm9-atmel-linux-ulibceabi % A verifier
    \item sh4-st-unknown: Pas de libc, permet de compiler le noyau
      et u-boot, mais pas d'application user
    \item i586-pc-mingw32msvc: Target windows
    \end{itemize}
  \item Attention, ça n'est pas une science exacte
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  \begin{itemize}
  \item 3 étapes: 
    \begin{itemize}
    \item On compile \cmd{arm-unknown-gcc}
    \item On configure le noyau pour installer les \emph{headers}
    \item On  compile la  \cmd{libc} avec \cmd{arm-unknown-gcc}  et le
      noyau préconfiguré, on compile le noyau
    \item On compile \cmd{arm-linux-libc-gcc}
    \end{itemize}
  \item Difficultés :
    \begin{itemize}
    \item Assez complexe
    \item Souvent des problèmes de compatibilité entre les versions
    \end{itemize}
  \end{itemize}
\end{frame}    

\begin{frame}[fragile=singleslide]{Compiler le cross-compiler et la libc}
  Différentes \cmd{libc}:
  \begin{itemize}
  \item glibc (``GNU C Library'', la vénérable)
  \item  eglibc  (``Embedded GNU  C  Library'',  meilleur support  des
    diverses  architectures.  Utilisée  depuis peu  sur  diverses
    distributions ``desktop'')
  \item newlib (utilisée par Cygwin) 
  \item µclibc (très utilisée dans l'embarqué)
  \item  dietlibc  (encore  plus   petite  que  µlibc  destinée  à  la
    compilation statique)
  \item bionic (Android)
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  Crosstool-NG :
  \begin{itemize}
  \item Système automatisant toute la procédure et intégrant les patchs
    connus pour rendre compatible certains systèmes
  \item Principalement maintenu par Yann Morin (cocoricco)
  \item Il n'existe  pas de paquet, nous devons  donc le compiler nous
    même:
    \begin{lstlisting}
host% apt-get install automake libtool texinfo flex bison gawk ...
host$ wget http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.13.4.tar.bz2
host$ tar xvzf crosstool-ng-1.13.4.tar.bz2
host$ cd crosstool-ng-1.13.4
host$ ./configure && make
host% make install
    \end{lstlisting}
  \end{itemize}
\end{frame}
   
\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
  \item Préparation du répertoire de build
    \begin{lstlisting}
$ mkdir ct-build ct-dl
$ cd ct-build
$ ct-ng help
    \end{lstlisting}
  \item Partons de l'exemple le plus proche de notre configuration
    \begin{lstlisting}
$ ct-ng list-samples
$ ct-ng arm-unknown-linux-uclibcgnueabi
    \end{lstlisting}
  \item Vérifions que le l'exemple compile
    \begin{lstlisting}
$ ct-ng build
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
  \item Configurons notre chaîne de compilation finale
    \begin{lstlisting}
$ ct-ng clean 
$ ct-ng menuconfig
       \end{lstlisting}
     \item Dans la configuration
       \begin{lstlisting}
... Prefix directory: /opt/${CT_TARGET}
... Remove documentation 
... Build Static Toolchain
# Documentation du CPU + man gcc + wikipedia (http://en.wikipedia.org/wiki/ARM_architecture)
... Architecture level: armv5te
# Page de man de gcc + documentation du CPU :
... Emit assembly for CPU: arm926ej-s
... Tuple's vendor string : sysmic
... Threading implementation to use: (nptl) 
... Add support for locales
       \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
     \item Compilons
       \begin{lstlisting}
$ chmod 777 /opt
$ ct-ng build
$ ct-ng tarball
       \end{lstlisting}
     \item Testons en statique
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ /opt/arm-sysmic-linux-uclibcgnueabi/bin/arm-sysmic-linux-uclibcgnueabi-gcc -static -Wall hello.c -o hello-mygcc-static
target$ ./hello-mygcc-static
       \end{lstlisting}
     \item Testons en dynamique
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ /opt/arm-sysmic-linux-uclibcgnueabi/bin/arm-sysmic-linux-uclibcgnueabi-gcc -Wall hello.c -o hello-mygcc
target$ ./hello-mygcc
	\end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler la toolchain}{Crosstool-NG}
  \begin{itemize}
      \item Il  possible (probable) que les bibliothèques  et le format
        de  binaire  ne  soient   pas  compatibles  avec  la  toolchain
        existante.    Il  est   alors  nécessaire   de   recopier  les
        bibliothèques  provenant de toolchain  et de  recompiler TOUTES
        les binaires du système
      \item Ajoutons quelques liens symboliques bien pensés
       \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ cd /opt/arm-unknown-linux-uclibcgnueabi/bin
host$ for i in arm-unknown-linux-uclibcgnueabi-*; do 
> ln -s $i arm-linux-${i#arm-unknown-linux-uclibcgnueabi-}; 
> done
	\end{lstlisting}
      \item N'espérez  pas compiler  du premier coup.  Mais autrefois,
        c'était pire!
      \end{itemize}
\end{frame}


% \section{Initramfs}

% \begin{frame}[fragile=singleslide]{Initramfs}
%   \begin{itemize}
%   \item Qu'est-ce qu'un initramfs?
%   \item Un petit filesystème chargé en mémoire par le bootloader
%   \item Successeur de initrd (plus complexe d'utilisation)
%   \item Permet déffectuer des actions avant le lancement d'init
%   \item Il devrait rester petit et ne s'utiliser que pour continuer le
%     boot
%   \item  Si  vous  intégrez  busybox  dans  votre  initramfs,  il  est
%     préconisé  de  le compiler  en  statique  en  ne gardant  que  les
%     composant utiles
%   \item  Cas classique:  charger les  modules permettent  d'acceder au
%     filesystème:
%     \begin{itemize}
%     \item M-Sys Disc-On-Chip
%     \item Configuration RAID
%     \item Configuration réseau pour booter en NFS
%     \end{itemize}
%   \item Dans notre cas, il n'est pas utile car nous n'avons pas besoin
%     de charger de driver particuliers avant le démarrage
%   \end{itemize}
% \end{frame}  

% \begin{frame}[fragile=singleslide]{Initramfs}
%   \begin{itemize} 
%   \item Création d'un rootfs vraiment minimal:
%     \begin{lstlisting}
% host$ mkdir initramfs
% host$ cd initramfs
% host$ mkdir dev
% host$ mknod dev/console c 5 1
% host% cp .../hello-arm-static init
% host$ find . |  cpio -o | gzip > initramfs.gz
%     \end{lstlisting}
%   \item Comme l'image noyau, l'image initramfs doit être au format u-boot.
%     \begin{lstlisting} 
% host$ mkimage -A arm -T ramdisk -d initramfs.gz initramfs.gz.img
% host$ cp initramfs.gz.img /srv/tftp
% uboot> tftp 21000000 initramfs.gz.img
%     \end{lstlisting}
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile=singleslide]{Initramfs}
%   \begin{itemize} 
%   \item  On  indique  l'adresse   du  ramfs  en  second  paramètre  de
%     \cmd{bootm}. Evidement, le noyau doit être configuré pour utiliser
%     le ramfs.
%     \begin{lstlisting} 
% uboot> setenv autostart no
% uboot> tftp 22000000 initramfs.gz.img 
% uboot> tftp 21000000 uImage 
% uboot> bootm 21000000 22000000 
%     \end{lstlisting}
%   \end{itemize}
%   \note[item]{TODO P1 A verifier, tester, completer}
% \end{frame}

\section{Flasher le rootfs}

\begin{frame}[fragile=singleslide]{Création du rootfs}
  Pour créer une image \cmd{jffs2}, vous devez au minimum spécifier le
  répertoire  de source,  l'image de  destination, l'endianness  et le
  padding:
  \begin{lstlisting} 
target% cat /proc/mtd
host% apt-get install mtd-utils
host$ mkfs.jffs2 -l -p -r nfs -o rootfs.jffs2
  \end{lstlisting}
  Afin de rendre notre image  plus performante, ajustons la taille des
  pages,  supprimons  les  cleanmarkers  (on pourrait  aussi  utiliser
  \verb+-c 0+) et changeons le propriétaires des fichier en root:
  \begin{lstlisting} 
host$ mkfs.jffs2 -l -p -q -n -s 2048 -e 128 -r nfs -o rootfs.jffs2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  Le  plus  générique pour  recopier  la flash  sur  la  cible est  de
  démarrer Linux par un autre moyen  (NFS ou partition de rescue) et 
  d'utiliser les outils Linux.
  \begin{itemize} 
  \item    Il   existe   des    fichiers   devices    \verb+mtd*+   et
    \verb+mtdblock*+:
    \begin{itemize} 
    \item Les fichiers block ne sont là que pour la compatibilité avec
      certains outils.  Ils ne gèrent  pas les \emph{badblock}  et les
      \emph{clean markers}.
    \item  Il  est préférable  de  passer  le  plus possible  par  les
      fichiers \verb+mtd*+
    \item  Les  flashs  doivent   être  écrites  en  prenant  certaines
      précautions (padding  sur les pages, etc...).  Il est préférable
      de systématiquement écrire en utilisant les outils spécialisés
    \end{itemize} 
  \item Toujours commencer par effacer le contenu précédent (on risque
    sinon des corruptions sur le filesystem)
    \begin{lstlisting}
target% flash_eraseall /dev/mtd1
target% cd /tmp
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  \begin{itemize} 
  \item Téléchargeons  le rootfs sur  notre cible. Nous  pouvons avoir
    des problèmes  de place pour stoker  cette image.  Il  est dans ce
    cas préférable de  travailler sur NFS (mais ca  n'est pas toujours
    possible).
    \begin{lstlisting} 
target% tftp -g -r rootfs.jffs2 host
target% nandwrite -p /dev/mtd1 rootfs.jffs2
    \end{lstlisting}
    ou bien
    \begin{lstlisting} 
host$ serve_image 0.0.0.0 1234 rootfs.jffs2 128
target% recv_image host 1234 /dev/mtd1
    \end{lstlisting} 
  \item  Test
    \begin{lstlisting}
target% mkdir /tmp/mtd1
target% mount -t jffs2 /dev/mtdblock1 /tmp/mtd1
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le système sur la flash}
  Il est possible d'effectuer cette opération à partir de U-Boot.
  \begin{itemize} 
  \item Nous allons utiliser TFTP sans démarrer dessous. Désactivons l'autostart
    \begin{lstlisting} 
uboot> set autostart no
    \end{lstlisting} 
  \item Toujours effacer la flash avant de flasher
    \begin{lstlisting} 
uboot> nand erase clean 1000000 7800000
    \end{lstlisting} 
  \item On place l'image en mémoire afin de la flasher
    \begin{lstlisting} 
uboot> tftp 21000000 rootfs.arm.jffs2
uboot> nand write 21000000 1000000 5A0000
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Recopier le noyau sur la flash}
  L'opération est similaire au filesystem. Dans la plupart des cas, on
  place le  noyau à  part sur  une autre partition  de la  flash. Nous
  n'avons alors pas besoin de filesystem:
  \begin{itemize} 
  \item Sous Linux
    \begin{lstlisting}
target% flash_erase /dev/mtd0 0x400000 0
target% cd /tmp
target% tftp -g -r uImage
target% nandwrite -s 0x400000 -p /dev/mtd0 uImage 
    \end{lstlisting}
  \item Sous U-boot
    \begin{lstlisting} 
uboot> tftp 21000000 uImage
uboot> nand erase clean 400000 200000
uboot> nand write 21000000 400000 200000
    \end{lstlisting} 
  \end{itemize}
\end{frame}

%\begin{frame}[fragile=singleslide]{Automatisation}
%  Les  options  non utilisées  par  le  noyau  sont passées  au  script
%  d'initialisation.   Ajoutons  une   option  permettant   de  flasher
%  automatiquement notre cible:
%  \begin{lstlisting}
%if [ $1 == FLASH ]
%  flash_eraseall /dev/mtd0
%  flash_eraseall /dev/mtd1
%  cd /tmp
%  nandwrite -p /dev/mtd0 uImage
%  nandwrite -p /dev/mtd1 rootfs.jffs2
%fi
%  \end{lstlisting}
%\end{frame}

\begin{frame}[fragile=singleslide]{Monter le rootfs sur l'hôte}
  L'hôte  ne possédant  pas  de  flash, nous  devons  la simuler  pour
  pouvoir monter le rootfs:
  \begin{itemize} 
  \item  Chargeons le  module  permettant l'émulation  d'une flash  et
    copions notre image sur la flash virtuelle
    \begin{lstlisting}
host% modprobe mtdram total_size=65536 erase_size=256
host% nandwrite -p /dev/mtd0 rootfs.jffs2
    \end{lstlisting}
  \item  Alternativement, il  est  possible de  directement mapper  un
    fichier sur une flash avec \file{block2mtd}
    \begin{lstlisting}
host% losetup /dev/loop0 rootfs.jffs2
host% modprobe block2mtd block2mtd=/dev/loop0
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Monter le rootfs sur l'hôte}
  \begin{itemize} 
  \item Chargeons la couche d'émulation par block et le filesystem
    \begin{lstlisting}
host% modprobe mtdblock
host% modprobe jffs2
    \end{lstlisting}
  \item Copie de notre image
    \begin{lstlisting} 
host% mkdir jffs2-mount
host% mount -t jffs2 /dev/mtdblock0 jffs2-mount
    \end{lstlisting} 
  \end{itemize}
  % http://wiki.maemo.org/Modifying_the_root_image
\end{frame}

\note{Est-ce que l'on ne devrait pas placer les chapitre sur u-boot et SAm-BA ici? Je pense que oui}

\section{Simuler}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  \begin{itemize}
  \item Machine Virtuelle
  \item Comparé à VirtualBox et VMWare:
    \begin{itemize}
    \item Plus polyvalent
    \item ...mais un peu  moins intuitif (possibilité d'utiliser qtemu
      ou qemulator)
    \end{itemize}
  \item Rapide car:
    \begin{itemize}
    \item Utilise la compilation JIT (Just-In-Time)
    \item Utilise des extensions du processeur pour gérer les
      adresses virtuelles (Module KVM, \emph{Nested paging})
      \begin{lstlisting}
host% apt-get install qemu-kvm-extras
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  Emule:
  \begin{itemize}
  \item Simplement un jeux d'instruction 
    \begin{itemize}
    \item Toutes les grandes architectures sont supportées
    \item  Les  appels  système  sont  alors bindez  vers  les  appels
      systèmes de l'hôte
      \begin{lstlisting}
host% qemu-arm ./hello-arm-static
host% qemu-arm -L ../arm-linux-uclibceabi/ ./hello-arm-debug
      \end{lstlisting}
    \item Utilisé par Scratchbox
      \begin{itemize}
      \item Scratchbox crée un chroot et utilise fakechroot
      \item Qemu  doit être compilé  en static pour être  utilisé avec
        fakechroot (sombre histoire de libld) % A vérifier
      \end{itemize}
    \item Ne permet pas d'avoir un périphérique virtuel
    \end{itemize}
  \item Un système
    \begin{itemize}
    \item Il est possible  d'émuler des périphériques non existants sur
      PC
    \item  Il  est  possible  avec  un peu  d'effort  de  simuler  des
      périphériques spéciaux.
    \item Simulation de systèmes complets. QA
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qu'est-ce que Qemu?}
  \begin{itemize}
  \item Le  port série de l'AT91  n'est pas présent dans  la liste des
    périphériques de Qemu
  \item On va donc simuler une autre board
  \end{itemize}
  \begin{lstlisting}[basicstyle=\ttfamily\scriptsize\color{colBasic}]
host$ wget http://wiki.qemu.org/download/arm-test-0.2.tar.gz
host$ tar xvzf arm-test-0.2.tar.gz
host$ qemu-system-arm -M integrator -cpu arm926 -m 16 -kernel zImage.integrator -initrd arm_root.img
host$ qemu-system-arm -M integrator -cpu arm926 -m 16 -kernel zImage.integrator -initrd arm_root.img -nographic -append "console=ttyAMA0"
  \end{lstlisting}
\end{frame}

% Acceder aux disque Qemu sans  démarrer Qemu: Before you can use this
% command you  need to  have the NBD  kernel module  loaded ('modprobe
% nbd') then you  can map the virtual harddisk file  to the nbd device
% ('qemu-nbd -vc/dev/nbd0  HD image.qcow') this will work  with any HD
% image format supported by qemu.   This will create a device for each
% partition in the virtual hard disk  file. You can then mount the the
% partions  like 'sudo mount  /dev/nbd0p1 /mnt'  When done  you should
% unmount ('umount  /mnt') and  disconnect the HD  image from  the nbd
% device ('qemu-nbd -d /dev/nbd0') -> On peut aussi utiliser xmount

% Dimensionner une syst`eme Linux embarqué
%    \item PC ou autre?
%    \item Linux ou autre?
%    \item Voir livre de Pierre Ficheux

% TODO: Compiler X et Qt pour Integrator

\section{Automatisation}

\begin{frame}[fragile=singleslide]{Automatisation}{Buildroot}
  \begin{itemize}
  \item But: créer un filesystem root
  \item Utilisation de Kconfig
  %\item Thomas Petazzoni
  \item Permet d'automatiser la création  de la toolchain, du noyau,
    de busybox et d'environ 300 outils
    \begin{itemize}
    \item serveurs http, ftp, ssh, etc..
    \item outils réseau, wireless, bluetooth, etc...
    \item Serveur X, gtk
    \end{itemize}
  \item Architecture assez propre
  \item Extension relativement simple ou nous retrouvons les commandes
    utilisées pour compiler des programmes tiers
  \item C'est un peu l'extension de Busybox
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{Buildroot}
  \begin{itemize}
  \item Récupération des sources
    \begin{lstlisting}
host$ wget http://buildroot.uclibc.org/downloads/buildroot-2010.11.tar.bz2
host$ tar xvf buildroot-2010.11.tar.bz2
host$ cd buildroot-2010.11
    \end{lstlisting} 
  \item  Utilisation  d'une configuration  pré-établie  comme base  de
    configuration
    \begin{lstlisting}
host$ make usb-a9260_defconfig
host$ make menuconfig
host$ make linux26-menuconfig
host$ make uclibc-menuconfig
host$ make busybox-menuconfig
host$ make all
    \end{lstlisting}
  \item Documentation: \url{http://buildroot.uclibc.org/buildroot.html}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{OpenEmbedded et Yocto}
  \begin{itemize}
  \item But: créer une distribution type Debian
  \item Gère un système de paquets
  \item Assez lourd à la configuration
  \item Très lourd de créer un nouveau type de cible
  \item ... mais relativement simple de gérer des dizaines de cibles
  \item Beaucoup de paquets sont déjà préparés (~1800)
    \begin{itemize}
    \item ... Principalement, toute la suite Gtk Opie
    \end{itemize}
  \item Yocto remplace peu à peu OpenEmbedded dans les nouveau projet
  \item Il est poussé pour la Linux Foundation
%  \item remplacé par Buildroot et Scratchbox 
%   \note[item]{Tout ici: \url{http://www.at91.com/linux4sam/bin/view/Linux4SAM/OpenEmbeddedAngstromBuild}}
%   \note[item]{Résultat ici: \url{ftp://www.at91.com/pub/demo/linux4sam_2.0/linux4sam-angstrom-at91sam9260ek.zip}}
%   \item  Récupératon d'une version d'OpenEmbedded ppackagə pour notre architecture
%   \begin{lstlisting}
% wget ftp://ftp.linux4sam.org/pub/oe/linux4sam_x.y/oe_at91sam.tgz
% tar xvzf oe_at91sam.tgz

% vim oe_at91sam/conf/local.conf
% source ./oe_env.sh
% apt-get install bitbake
% bitbake base-image
% bitbake console-at91sam9-image
% bitbake x11-at91sam9-image
%   \end{lstlisting}
    \note[item]{TODO P4: Faire fonctionne OpenEmbedded et Yocto}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Automatisation}{Strachbox}
  \begin{itemize}
  \item but: créer une distribution type Debian
  \item Utilisé  par Meego (Nokia,  intel, Renault, etc..)  et Android
    (en cours)
  \item packagé: \verb+apt-get install scratchbox2+
  \item Coquille vide
    \begin{itemize}
    \item On peut installer l'environnement de Maemo ou de Android
    \end{itemize}
  \item Basé sur un fonctionnement hybride avec qemu
    \begin{itemize}
    \item On compile avec le  cross-compiler mais le reste est exécuté
      avec qemu ou en ssh sur la cible
    \item S'utilise comme un environnement de compilation normal
    \item Rend la cross-compilation transparente
    \item Fonctionne pour ARM and  x86 targets (PowerPC, MIPS and CRIS
      targets are experimental)
    \item  Permet de  compiler certains  paquets ne  pouvant  pas être
      cross-compilés (Notablement Python)
    \item Dépend du bon fonctionnement de qemu
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qemu et Scratchbox}
  \begin{itemize} 
  \item Installation
    \begin{lstlisting}
host% apt-get install scratchbox2
host$ mkdir scratchbox
host$ cd scratchbox
    \end{lstlisting}
  \item Initialisation de l'environnement. Nous utilisons \cmd{qemu-arm} pour
    lancer nos binaires cibles et \cmd{arm-linux-gcc} comme compilateur
    \begin{lstlisting} 
host$ sb2-init -c qemu-arm -n A926 arm-linux-gcc
    \end{lstlisting}
  \item Démarrage de l'environnement 
    \begin{lstlisting} 
host$ sb2
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Qemu et Scratchbox}
  \begin{itemize} 
  \item La cross-compilation est transparente
    \begin{lstlisting} 
qemu$ gcc hello.c -static -o hello-sb2-static
qemu$ file hello-sb2-static
qemu$ ./hello-sb2-static
qemu$ gcc hello.c -o hello-sb2
qemu$ file hello-sb2
    \end{lstlisting}
  \item Comme  sur la cible,  nous avons besoin que  les bibliothèques
    soient bien configurées dans notre environnement
    \begin{lstlisting} 
qemu$ cp -a /opt/arm-unknown-linux-uclibcgnueabi/arm-unknown-linux-uclibcgnueabi/sysroot/lib .
qemu$ ./hello-sb2
    \end{lstlisting} 
  \end{itemize} 
\end{frame}




