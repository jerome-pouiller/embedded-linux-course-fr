% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Copyright 2010 Jérôme Pouiller <jezz@sysmic.org>
%

\part{Administrer}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Notre environement}

\subsection{Linux}

\begin{frame}{Qu'est-ce que Linux?}
  \begin{itemize}
  \item  Linux ne désigne  que le  noyau
    \note[item]{nous  verrons ce  qu'est le noyau}
  \item  Linux est  souvent  associé aux  outils  GNU d'où  le nom  de
    GNU/Linux
  \item  Systèmes  avec  les  outils  GNU  mais  un  noyau  différent:
    GNU/Hurd, Solaris, etc...
  \item Systèmes Linux sans GNU: Android\note[item]{Bionic}
  \item Le nombre de systèmes  Linux installés est difficile à évaluer
    (en partie à cause des système Linux embarqués)
  \end{itemize}
\end{frame}

\begin{frame}{Composants de Linux}
  GNU/Linux est finalement un aggloméra:
  \\[2ex]
  \begin{center}
    \begin{tikzpicture}
      \filldraw[cbrown]
       (-0.05,0.95) -- +(9,0) -- +(9,1) -- +(8,1) -- +(8,2) -- +(7,2) -- +(7,3)
       -- +(6,3) -- +(6,4) -- +(2,4) -- +(2,3) -- +(1,3) -- +(1,1) -- +(+0,1) -- cycle;
% node {Posix};
     \filldraw[ccyan]
       (7,5) -- +(1,0) -- +(1,-1) -- +(1.9,-1) -- +(1.9,0.9) -- +(0,0.9) -- cycle +(1,.5) node {App};
     \filldraw[ccyan]
       (1,5) rectangle +(1.9,0.9) +(1,.5) node {App};
     \filldraw[ccyan]
       (6,4) rectangle +(1.9,0.9) +(1,.5) node {App};
     \filldraw[cyellow]
       (4,4) rectangle +(1.9,0.9) +(1,.5) node {GNU App};
     \filldraw[cyellow]
       (2,4) rectangle +(1.9,0.9) +(1,.5) node {Bash};
     \filldraw[ccyan]
       (1.9,4) -- +(-1,0) -- +(-1,-2) -- +(-1.9,-2) -- +(-1.9,0.9) -- +(0,0.9) -- cycle +(-1,.5) node {App};
     %\filldraw[cyellow]
     %  (0,4) rectangle +(1.9,0.9) +(1,.5) node {App};
     \filldraw[cblue]
       (7,3) -- +(1,0) -- +(1,-1) -- +(1.9,-1) -- +(1.9,0.9) -- +(0,0.9) -- cycle +(1,.5) node {Lib};
     \filldraw[corange]
       (3,3) rectangle +(3.9,0.9) +(2,.5) node {GNU lib};
     \filldraw[corange]
       (1,2) -- +(6.9,0) -- +(6.9,0.9) -- +(1.9,0.9) -- +(1.9,1.9) -- +(0,1.9) -- cycle +(3.5,.5) node {GNU libc};
     \filldraw[cred]
       (0,1) rectangle +(8.9,0.9) +(4.5,.5) node {Noyau Linux};
     \filldraw[cgreen]
       (0,0) rectangle +(8.9,0.9) +(4.5,.5) node {Matériel};
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}{La Norme Posix}
  \begin{itemize}
  \item \emph{Portable Operating System Interface [for Unix]}
  \item Uniformise les OS
  \item Première version publiée en 1988
  \item Souvent implémentée en partie
  \item ...  et parfois  s'en inspire simplement
    \note[item]{Parler de uC-OS II, \texttt{printf}, etc...}
  \item Posix $\nrightarrow$ Linux
  \item Linux $\nrightarrow$ Posix
  \end{itemize}
\end{frame}

\begin{frame}{Le Projet GNU}
  \begin{itemize}
  \item Créé en 1983 par Richard Stallman
  \item Pose  les bases politiques  de GNU/Linux
    \note[item]{Expliquer ce qu'est la GPL}
    \begin{itemize}
    \item GPL publiée en 1989
    \item GPLv2 en 1991
    \item GPLv3 en 2006
    \end{itemize}
  \item \cmd{gcc} apparait en 1985
    \note[item]{Expliquer ce qu'est gcc}
  \item \cmd{bash} et les  Coreutils apparaissent en 1988 (inspirés de
    \cmd{sh} 1971/1977)
    \note[item]{Expliquer coreutils}
    \note[item]{Expliquer   bash}
  \item Nombre d'architectures supportées incalculable
  \end{itemize}
\end{frame}

\begin{frame}{Le noyau Linux}
  \begin{itemize}
  \item Créé  en 1991 par  Linus Torvalds \note[item]{Parler  de Linus
      l'universitaire}
  \item Système communautaire \note[item]{Parler du lien avec la GPL}
  \item 15 millions de lignes de code dans 30000 fichiers (+15\%/an)
  \item Environ 1200 développeurs dans 600 entreprises (+35\%/an)
  \item Environ 5000 contributeurs depuis la première version de Linux
  \item  Environ  650  mainteneurs  (c'est-à-dire  responsbales  d'une
    partie du noyau)
  \item Domaine d'application très large, du DSP au super-calculateurs
    en passant pas les grille de calcul
  \item 24 architectures (= jeux d'instructions)
  \item Des centaines de plateformes
  \item Environ 1000 drivers
  \item Une centaine de versions publiées
  \item Environ 10000 contributions sur chaque version
  \item Enormément de ``forks'' et de version non-officielles
  \end{itemize}
\end{frame}

\begin{frame}{Qu'est-ce qu'une distribution?}
  \begin{itemize}
  \item Debian, Ubuntu, Meego,  Red Hat, Suse, ... \note[item] {Parler
      de Meego, dériv sur Intel, Nokia, Renault, etc... Dire que c'est
      en plein essort}
  \item Compilations de programmes disponibles pour GNU/Linux
  \item Ensemble de normes et de procédure
  \item Permet de garantir le fonctionnement des programmes distribué
  \item Notre distribution ``Hôte'': Ubuntu % à vérifier
  \item Notre distribution ``Cible'': Aucune
  \end{itemize}
\end{frame}

\subsection{L'embarqué}

\begin{frame}{Qu'est-ce que l'embarqué?}
  D'après Wikipedia:
  \begin{quote}
    \justify  Un système embarqué  peut être  défini comme  un système
    électronique et  informatique autonome, qui est dédié  à une tâche
    bien  précise.   Ses   ressources  disponibles  sont  généralement
    limitées.   Cette  limitation  est  généralement  d'ordre  spatial
    (taille limitée) et énergétique (consommation restreinte).
    \\[2ex]
    Les systèmes  embarqués font très souvent  appel à l'informatique,
    et notamment aux systèmes temps réel.
    \\[2ex]
    Le terme de système embarqué désigne aussi bien le matériel que le
    logiciel utilisé.
  \end{quote}
\end{frame}

\begin{frame}{Cible et Hôte}
  \begin{itemize}
  \item  Nous parlerons  de système  cible  (target, la  board) et  de
    système hôte (host, votre machine)
  \item Le  host va nous permettre de  programmer, debugger, contrôler
    le système cible durant la période de développement
  \item Le système cible sera ensuite autonome.
  \item Nous utilisons un Linux sur les deux systèmes. Cela  n'est pas
    une obligation (même, si cela facilite certains automatismes).
  \end{itemize}
\end{frame}

\begin{frame}{La cible: Calao USB-A9260}
  \begin{center}
    \pgfimage[height=5cm]{pics/USB-AT91-1}\hspace{1cm}\pgfimage[height=5cm]
    {pics/USB-AT91-2}
  \end{center}
\end{frame}

\begin{frame}{La cible: Calao USB-A9260}
  Architecture très classique dans le milieu de Linux embarqué:
  \begin{itemize}
  \item Microcontrolleur Atmel AT91SAM9260
  \item Core ARM926EJ-S 180MHz
  \item 256Mo de flash
  \item 64Mo de RAM
  \item 64Ko d'EEPROM
  \end{itemize}
  Choisie  car  compacte,  bien   documentée,  ouverte  et  très  bien
  supportée par Linux
  \note[item]{Mettre la ref exacte, parle de la JTAG, de FTDI, du BSP,
    montrer les documentation ATMEL et les plan de cablage}
\end{frame}

\section{Le shell}

\subsection{Bases}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}{Bases}
  \begin{itemize}
  \item Sous Linux,  on peut faire beaucoup de choses  avec la ligne de
    commande
  \item Très souvent, ce sera le seul langage de script disponible sur
    la cible
  \item Lancer une commande
\begin{lstlisting}
$ ls
\end{lstlisting} %$
  \item Séparation des arguments par des espaces
\begin{lstlisting}
$ mkdir dir1 dir2
\end{lstlisting} %$
    \item Souvent  les arguments optionnels commence par  '\cmd{-}' pour les
      options courtes et '\cmd{--}'  pour les options longues (attention aux
      exceptions)
\begin{lstlisting}
$ ls -l -a
$ ls -la
$ ls --sort=time
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}{Redirections}
  On utilise beaucoup les  redirections des entrées/sorties sous Linux
  (\verb+< | >+) :
  \begin{itemize}
  \item Commande standard
\begin{lstlisting}
$ echo foo
\end{lstlisting}
  \item Sortie standard vers un fichier
\begin{lstlisting}
$ echo foo > file1
\end{lstlisting}
  \item Un fichier vers l'entrée standard
\begin{lstlisting}
$ cat -n < file1
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}{Redirections}
  \begin{itemize}
  \item Sortie standard d'une commande vers l'entrée d'une autre
\begin{lstlisting}
$ echo bar foo | wc
$ ls | wc -l
\end{lstlisting}
  \item Couplage des redirections
\begin{lstlisting}
$ cat -n < file1 | wc > file3
\end{lstlisting} %$
  \item L'espace n'est pas obligatoire et les redirections ne sont pas
    forcement à la fin de la ligne
\begin{lstlisting}
$ >file2 cat<file1 -n
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}{Les chemins}
  Il est possible d'utiliser des chemins:
  \begin{itemize}
  \item absolus
\begin{lstlisting}
$ mkdir /tmp/tete
\end{lstlisting}
  \item relatifs
\begin{lstlisting}
$ mkdir ../../tmp/titi
\end{lstlisting}
  \end{itemize}
  \cmd{mkdir foo} signifie \cmd{mkdir ./foo}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}
  \begin{itemize}
   \item   Documentation:  \cmd{man}  (\cmd{man   -l}  pour   une  page
     ``locale''). \verb+</>+ et \verb+<?>+ permettent de rechercher dans une page de man
  \item  Globbing   (à  ne   pas  confondre  avec   les  expressions
    régulières)
    \begin{lstlisting}
$ rm *.o
    \end{lstlisting}
  \note[item]{Parler  de  grep,   des  expression  régulière  et  la
    différence avec le  globbing}
  \item Alias
    \begin{lstlisting}
$ alias ll="ls -l --color=auto"
$ alias cp="cp -i"
$ alias mv="mv -i"
$ alias rm="rm --one-file-system"
    \end{lstlisting} %$
  \note[item]{Leur faire chercher dans  la doc la signification de
    ces commandes}
  \item Complétion (permet d'aller plus vite et se protèger des fautes de frappe)
      \begin{lstlisting}
$ cd /h<TAB>/j<TAB>/c<TAB>
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques notions de shell}
  \begin{itemize}
    \item Quelques séquences de touches:
      \begin{itemize}
      \item \cmd{<Home>}/\cmd{<End>}: début/fin de ligne
      \item \cmd{<Ctrl+Left>}/\cmd{<Ctrl+Right>}: se déplacer d'un mot à l'autre
      \item \cmd{<Up>}/\cmd{<Down>}: se déplacer dans l'historique des commandes
      \item \cmd{<Ctrl+R>}: rechercher dans l'historique. \cmd{<Ctrl+R>} de nouveau pour itérer
      \end{itemize}
      \note[item]{Leur faire changer de shell et installer ma conf}
    \item Utilisez le copier-coller à la souris
      \begin{itemize}
      \item selection: copie
      \item click-milieu: colle
      \item double-click: selectionne le mot
      \item triple-click: selectionne la ligne
      \end{itemize}
    \note[item]{Exo: créer  un fichier contenant la  liste des fichier
      de votre home.  Comment afficher les fichier trié par date?}
    \note[item]{Exo: Quel fichier inclure pour utiliser dlopen?}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Ecrire un script shell}
  Les  fonctionnalités d'un  script  shell sont  abolument identiques  à
  celles de la ligne de commande.
  \begin{itemize}
  \item Ouvrir  un nouveau fichier. On suffixe  généralement les shell
    par \file+.sh+
    \begin{lstlisting}
$ vim script.sh
    \end{lstlisting} %$
  \item Indiquer  le shell utilisé  sur la première ligne,  préfixé de
    \verb+#!+
    \begin{lstlisting}
#!/bin/sh
    \end{lstlisting} %$
  \item La suite s'ecrit comme sur la ligne de commande
    \begin{lstlisting}
echo foo bar
    \end{lstlisting} %$
  \item Il est nécéssaire de donner les droits en exécution au script
    \begin{lstlisting}
$ bash script.sh
$ chmod +x script.sh
$ ./script.sh
    \end{lstlisting} %$
    \note[item]{Ecrivez  un  script  shell  qui compte  le  nombre  de
      fichier d'un répertoire en paramètre. Compter le nombre de ligne
      contenant 'x' dans un fichier  (man grep). Afficher le plus gros
      fichier du répertoire}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Convention}
  Par convention,  nous préfixons dans ces slides  les commandes shell
  par :
  \begin{itemize}
  \item  \verb+$+  pour les  commandes  à  exécuter par  l'utilisateur
    normal
  \item \verb+%+ pour les commandes à exécuter par root
  \item \verb+>+ pour les commandes non-shell
  \end{itemize}
  Nous  préfixons parfois  les commandes  shell par  le système  ou la
  commande doit être executée
\end{frame}

\section{Communiquer avec la cible}

\subsection{En RS232}

\begin{frame}{Se connecter par RS232}
  \begin{itemize}
  \item RS232  est très utilisé.  Vous trouverez peu de  systèmes sans
    RS232
  \item D'un point de vue électrique:  Gnd, Rx, Tx (+ RTS et CTS, mais
    inutile)
  \item Il  est relativement simple  de communiquer en RS232  avec une
    pin  de sortie du  processeur, mais  de nos  jours, on  utilise des
    contrôleurs RS232 qui simplifient énormément le travail
  \item On pourra trouver des  bus similaires et convertible en RS232:
    RS422, RS485
  \end{itemize}
\end{frame}

\begin{frame}{Se connecter par RS232}
  \begin{itemize}
  \item Il faut un câble nul modem (= câble croisé)
  \item Il faut que le Linux sur la cible soit configuré pour utiliser
    le port RS232 comme console
    \begin{itemize}
    \item Possible en ajoutant \texttt{console=ttyS0,115200n8} dans la
      ligne  de commande du  noyau (sur  PC, il  suffit de  passer par
      \emph{grub}) \note[item]{Faire une  démonstration, mais il n'y a
        pas de port série...}
    \item Possible de le mettre dans la configuration du noyau
    \end{itemize}
  \item Il faut sur le Linux  un programme pour se logguer sur le port
    RS232 (comme sur PC): \cmd{login} ou \cmd{getty}
    \note[item]{Expliquer rapidement}
    \note[item]{Faire booter la cible et faire executer quelques commandes}
  \item Il faut configurer le port RS232: bitrate, protocole...
  \end{itemize}
\end{frame}

\begin{frame}{Pourquoi n'y a-t-il pas de port série sur notre cible?}
  \begin{itemize}
  \item Vous savez qu'il existe des convertisseurs USB/RS232
  \item  Sur notre  cible, un  convertisseur USB/RS232  intégré  à la
    carte
  \item   Le  port  USB   que  vous   voyez  n'est   pas  vu   par  le
    micro-contrôleur.
  \item Il est  relié à une puce qui  effectue la conversion USB/RS232
    et   relie  la   connexion   série  à   la   sortie  console   du
    micro-contrôleur.
  \item Cela permet:
    \begin{itemize}
    \item d'économiser une alimentation (le PC alimente)
    \item  de  gagner la  place  d'un port  série  et  d'un port  Jtag
      \note[item]{nous verrons plus tard ce qu'est un port jtag}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiqer par RS232}{Avec les outils de haut niveau}
  \begin{itemize}
  \item Permettre d'accéder au port série sans être root:
\begin{lstlisting}[language=sh]
host% adduser user dialout
\end{lstlisting} %$
  \item Il est nécessaire de se relogguer pour que les modifications sur les
    groupes soient prises en compte
  \item Les outils de haut niveau:
  \begin{itemize}
  \item minicom: La référence
  \item picocom:   Fonctionne   sans  \emph{ncurses}   (mieux   pour
    l'automatisation)
  \item gtkterm: Fonctionne en graphique
  \item putty: Fonctionne sous Linux et sous Windows
  \end{itemize}
  \item Attention aux conflits avec certains services comme ModemManager
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiqer par RS232}{Minicom}
\begin{lstlisting}[language=sh]
host% apt-get install minicom
host$ minicom -D /dev/ttyUSB0
host$ minicom
\end{lstlisting} %$
  \note[item]{Expliquer l'option -D}
  La configuration se fait par \verb/<RET><Ctrl+A><O>/
\begin{lstlisting}[language=]
   Serial Device      : /dev/ttyUSB0
     ...
   Bps/Par/Bits       : 115200 8N1
Hardware Flow Control : No <- Important
Software Flow Control : No
\end{lstlisting}
    \note[item]{Sauvez, quitter, relancer}
  \note[item]{Lancer stty pour voir la configuration}
  \note[item]{Faire lancer quelques commandes}
  \note[item]{Expliquer fg/bg/jobs}
  \note[item]{Les cartes  doivent booter  directement sur la  flash et
    être prête à recevoir des binaires}
\end{frame}


\begin{frame}[fragile=singleslide]{Communiquer par RS232}{Avec les outils de bas niveau}
  Outils de bas niveau: \cmd{stty}, \cmd{cat}, \cmd{echo}
  \begin{itemize}
  \item Permet de scripter (Tests automatiques, etc...)
  \item Dans le cas ou vous devriez coder votre propre client
  \end{itemize}
  Fonctionnement:
  \begin{itemize}
  \item Configuration:
\begin{lstlisting}
host$ stty -F/dev/ttyUSB0 115200
\end{lstlisting} %$
  \item Lecture
\begin{lstlisting}
host$ cat /dev/ttyUSB0 > file
\end{lstlisting} %$
  \item Ecriture
\begin{lstlisting}
host$ echo root > /dev/ttyUSB0
host$ cat file > /dev/ttyUSB0
\end{lstlisting} %$
  \end{itemize}
  \note[item]{Verifier les options de stty}
\end{frame}

\begin{frame}[fragile=singleslide]{Rebooter la clef}
  Pour le fun:
  \begin{lstlisting}
host$ lsusb -t
host$ echo 3-1 | sudo tee /sys/bus/usb/drivers/usb/unbind
host$ echo 3-1 | sudo tee /sys/bus/usb/drivers/usb/bind
host$ dmesg | tail
  \end{lstlisting} %$
\end{frame}

\subsection{Par ethernet}

\begin{frame}[fragile=singleslide]{Communiquer par réseau ethernet}
  Plus difficile. Il faut:
  \begin{itemize}
  \item Une interface réseau (plus complexe qu'un controleur RS232)
  \item Une pile IP (plus complexe qu'une communication RS232, donc ne
    permet de se connecter que plus tardivement dans le boot)
  \item Une configuration IP
  \item Un programme  pour recevoir la demande de connexion
  \end{itemize}
\note[item]{Ne pas oublier de leur faire changer les mac si necessaire}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer par réseau ethernet}
  Protocoles les plus utilisés:
  \begin{itemize}
  \item Telnet
    \begin{itemize}
    \item \cmd{telnetd} et \cmd{telnet}
      \begin{lstlisting}
target% telnetd
host$ telnet -l root target
target%
      \end{lstlisting} %$
    \item   Pas   sécurisé,   attention   à   votre   mot   de   passe
      (\cmd{tshark -i lo -o out}, puis \cmd{chaosreader out})
      \note[item]{Pas de  telnetd sur la cible, du  coup, il faut
        le faire en local}
    \item \verb/<CTRL+]>/ permet d'accéder à l'interface de commande
    \end{itemize}
  \item Ssh
    \begin{itemize}
    \item \cmd{sshd} et \cmd{ssh}
\begin{lstlisting}
host$ ssh root@target
target%
\end{lstlisting} %$
    \item Sécurisé
    \item Plein de bonus de sécurisés
    \item   Il   est   possible   de  forcer   la   déconnexion   avec
      \verb/<RET><~><.>/   et   de   suspendre  une   connexion   avec
      \verb/<RET><~><CTRL+Z>/
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Transférer des fichiers}

\begin{frame}[fragile=singleslide]{Transférer des fichiers}
  Par réseau
  \begin{itemize}
  \item rcp/scp
\begin{lstlisting}[language=sh]
host$ scp -r ~/dir root@target:dir-target
target$ scp -r user@host:dir-host .
\end{lstlisting} %$
  \item tftp. La syntaxe dépend de l'implémentation.
  \note[item] \cmd{udpsvd -vE 0.0.0.0 69 tftpd -c /files/to/serve}
\begin{lstlisting}[language=sh]
target$ tftp host -g -r file
target$ tftp host -p -l file
host$ tftp target -c get file
host$ tftp target -c put file
\end{lstlisting} %$
  \item wget
\begin{lstlisting}[language=sh]
host$ wget http://host/file
host$ wget ftp://host/file
\end{lstlisting} %$
  \note[item]{TP: Just do it, surtout wget (implique apache)}
  \item Beaucoup d'autres méthodes plus ou moins standards
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Transférer des fichiers}
  Par liaison série
  \begin{itemize}
  \item Plus lent, moins malléable, mais peut vous sauver
  \item Protocoles \verb+{X,Y,Z}MODEM+ ou \verb+Kermit+
  \item \cmd{Ctrl+X} pluieurs fois pour annuler
  \item Les commandes \cmd{rz}/\cmd{sz} sont lancées sur le host par le terminal
    (ne fonctionne pas en autonome)
  \item \cmd{rz} est automatiquement lancé par le terminal sur la cible
  \item Le terminal détecte automatiquement la séquence de démarrage de \cmd{sz}
  \item Fonctionne bien dans minicom (\cmd{<Ctrl-A><S>}), Konsole
  \item Fonctionne dans picocom à condition d'utiliser \verb+Xmodem+
    (\cmd{--receive-cmd "rx"}) et de démarrer la reception manuellement
    (\cmd{<Ctrl-A><Ctrl-R>})
\begin{lstlisting}[language=sh]
host% apt-get install lrzsz
target$ sz file
target$ rz
<Ctrl-A><S>
\end{lstlisting} %$
    \note[item]{Fonctionne dans konsole ou dans minicom avec Ctrl-A S}
    \note[item]{Raconter le fonctionnement des BBS}
  \end{itemize}
\end{frame}

\subsection{Utilisation de clefs numériques}

\begin{frame}[fragile=singleslide]{Utiliser des clef ssh}
  \begin{itemize}
  \item Possibilité de créer des clefs pour \cmd{ssh}
\begin{lstlisting}[language=sh]
host$ ssh-keygen -t dsa
\end{lstlisting} %$
  \item Toujours mettre un mot de passe sur votre clef
  \item Recopiez votre clef dans \verb+~/.ssh/authorized_keys+
\begin{lstlisting}[language=sh]
host$ ssh-copy-id root@target
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Utiliser des clefs ssh}
  \begin{itemize}
  \item Utiliser \cmd{ssh-agent} (inutile de nos jours car déjà lancé avec la session)
\begin{lstlisting}[language=sh]
host$ ssh-agent
host$ SSH_AUTH_SOCK=/tmp/agent.3391; export SSH_AUTH_SOCK;
host$ SSH_AGENT_PID=3392; export SSH_AGENT_PID;
host$ echo Agent pid 3392;
\end{lstlisting} %$
  \item Enregistrer votre passphrase auprès de l'agent
\begin{lstlisting}[language=sh]
host$ ssh-add
\end{lstlisting} %$
  \item Forwarder votre agent
\begin{lstlisting}[language=sh]
host$ ssh -A root@target
target%
\end{lstlisting} %$
    \note[item]{TP: Mettre  l'agent pour tout le  monde. FIXME: depend
      des distribs}
  \end{itemize}
\end{frame}


\section{Compiler et executer}

\begin{frame}[fragile=singleslide]{Notre premier programme}{\file{hello.c}}
  \embedfile{samples/hello/hello.c}
  \lstinputlisting[language=c,lastline=15]{samples/hello/hello.c}
\end{frame}

\begin{frame}[fragile=singleslide]{Notre premier programme}{\file{hello.c}}
  \lstinputlisting[language=c,firstline=16]{samples/hello/hello.c}
\end{frame}

\begin{frame}[fragile=singleslide]{Notre premier programme}{\file{hello.h}}
  \embedfile{samples/hello/hello.h}
  \lstinputlisting[language=c]{samples/hello/hello.h}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation}
  \note[item]{Expliquer la compilation statique}
  \note[item]{Expliquer l'intérêt de la compilation out-of-source}
  \note[item]{\$PATH}
  Installation du compilateur:
  \begin{lstlisting}
host% apt-get install gcc libc-dev
  \end{lstlisting}
  Compilation normale:
  \begin{lstlisting}
host$ mkdir build-x86
host$ gcc hello.c -o build-x86/hello
host$ build-x86/hello 1
Hello World
\end{lstlisting} %$
Remarque: On préfère effectuer des compilation \emph{out-of-source} ou
les objets  se trouvent  séparés des sources.   Il est  ainsi possible
d'avoir un répertoire  pour la production et un pour  le debug ou bien
un répertoire par cible.
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation}
  Décompression de la toolchain:
  \begin{lstlisting}
host% cd /
host% tar xvzf .../arm-sysmic-linux-uclibcgnueabi_i386.tgz
  \end{lstlisting}
  \begin{itemize}
  \item   On  installe  très souvent  les  chaines  de cross-compilation  dans
    \path{/opt}.
  \item      Beaucoup      de      toolchain     ne      sont      pas
    \emph{relocable}.  C'est-à-dire  qu'elle  doivent  être  placée  à
    l'endroit où  elles ont été compilée (car  il contiennent certains
    chemins en ``dur'').
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compilation}
  Compilation pour la cible:
  \begin{lstlisting}
host$ mkdir build-arm
host$ /opt/arm-sysmic-linux-uclibc/bin/arm-linux-gcc hello.c -o build-arm/hello
  \end{lstlisting}
  ou bien
  \begin{lstlisting}
host$ PATH+=:/opt/arm-sysmic-linux-uclibc/bin
host$ arm-linux-gcc hello.c -o build-arm/hello
  \end{lstlisting}
  Test:
  \begin{lstlisting}
target% ./hello 1
Hello World
  \end{lstlisting} %$
\end{frame}

\begin{frame}[fragile=singleslide]{Identifier le résultat}
  Un bon moyen de reconnaître  les binaires est d'utiliser la commande
  \cmd{file}:
\begin{lstlisting}
host$ file */hello
arm/hello:        ELF 32-bit LSB executable, ARM, version 1 (SYSV), dynamically linked (uses shared libs), not stripped
arm-static/hello: ELF 32-bit LSB executable, ARM, version 1 (SYSV), statically linked, not stripped
x86/hello:        ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, not stripped
x86-static/hello: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.15, not stripped
\end{lstlisting} %$
\end{frame}

\begin{frame}{Compiler et exécuter}
  \begin{itemize}
  \item La force de Linux, c'est sa polyvalence
  \item Programmer  pour un Linux  embarqué n'est pas  très différent
    que sur un Linux PC.
  \item Principales différences à garder à l'esprit:
    \begin{itemize}
    \item Différence de vitesse de CPU et de quantité de mémoire
    \item Différence de périphérique. Conséquences:
      \begin{itemize}
      \item Drivers différents
      \item   Bibliothèques   différentes   (exemple:  Qt   dépend   de
        l'accélération graphique)
      \end{itemize}
    \item   Les  différence   d'architecture   CPU  peuvent   empêcher
      l'utilisation de  certains outils de debug  (ex: Perf, Valgrind,
      SystemTap...)
    \end{itemize}
  \item  Compiler   un  programme  pour  une   autre  cible  s'appelle
    cross-compiler
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Règle d'or}
  \begin{center}
    \huge{Jamais d'espaces dans les chemins de compilation}
  \end{center}
\end{frame}

\section{Compiler un programme tiers}

\subsection{Les Makefile}

\begin{frame}[fragile=singleslide]{Compiler avec un Makefile classique}
  \begin{itemize}
  \item Pas très normalisé
  \item Utilisé pour les petits projets ou les projets non standard
  \item Ressemble souvent à:
    \begin{lstlisting}
host$ make CC=arm-linux-gcc
    \end{lstlisting} %$
  \item Il peut être nécessaire d'avoir la chaîne de cross-compilation
    dans son \verb+PATH+.
    \begin{lstlisting}
host$ PATH+=:/opt/arm-sysmic-linux-uclibcgnueabi/bin
    \end{lstlisting} %$
  \item Ne pas hésiter à lire le \file{Makefile}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler avec un Makefile classique}
  Exemple avec \cmd{memstat}:
  \begin{itemize}
  \item Récupération des sources
    \begin{lstlisting}
host$ wget http://ftp.de.debian.org/debian/pool/main/m/memstat/memstat_0.9.tar.gz
    \end{lstlisting}
  \item Décompression des sources
\begin{lstlisting}
host$ tar xvzf memstat_0.9.tar.gz
\end{lstlisting}
  \item Compilation
\begin{lstlisting}
host$ cd memstat-0.9
host$ make CC=arm-linux-gcc LD=arm-linux-ld memstat
\end{lstlisting} %$
    \note[item]{TP}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler avec Makefile classique}
  Il est aussi souvent possible de compiler ces programmes sans passer
  par Makefile  ou de réécrire  le Makefile pour une  utilisation plus
  récurrente.
  \\[2ex]
  Exemple avec \cmd{memstat}:
\begin{lstlisting}
host$ make clean
host$ arm-linux-gcc memstat.c -o memstat
\end{lstlisting} %$
\end{frame}

\subsection{Les Autotools}

\begin{frame}[fragile=singleslide]{Compiler avec autotools}
  \begin{itemize}
  \item C'est le cas le plus courant
  \item Pour une compilation classique:
    \begin{lstlisting}
host$ ./configure
host$ make
host% make install
    \end{lstlisting} %$
  \item Compilation \emph{out-of-source}. il est nécessaire d'appeller
    le \file{configure} à partir du répertoire de build.
    \begin{lstlisting}
host$ mkdir build
host$ cd build
host$ ../configure
host$ make
host% make install
    \end{lstlisting} %$
  \item L'installation peut nécessiter les droits \emph{root}
    \begin{itemize}
    \item Utiliser \cmd{sudo -E} (attention à l'option \c{secure_path}
      dans \file{/etc/sudoers})
    \item Utiliser \cmd{fakeroot}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler avec autotools}
  \begin{itemize}
  \item  Compilation out-of-source:
    \begin{lstlisting}
host$ cd build
host$ ../configure
host$ make
host$ make DESTDIR=~/rootfs install
    \end{lstlisting} %$
  \item  Cross-compilation.
    \begin{lstlisting}
host$ PATH+=/opt/arm-sysmic-linux-uclibcgnueabi/usr/bin
host$ mkdir build && cd build
host$ ../configure --host=arm-linux --build=i386
host$ make
host$ make DESTDIR=~/rootfs install
    \end{lstlisting} %$
  \item  Il   est  aussi  possible  d'utiliser \cmd{-\-prefix=} lors du
    \cmd{./configure} au lieu (ou en plus) de \c{DESTDIR=}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler avec autotools}
  Exemple avec \cmd{lzma}:
  \begin{itemize}
  \item Récupération et décompression des sources
\begin{lstlisting}
host$ wget http://tukaani.org/lzma/lzma-4.32.7.tar.gz
host$ tar xvzf lzma-4.32.7.tar.gz
host$ cd lzma-4.32.7
\end{lstlisting} %$
  \item Configuration
\begin{lstlisting}
host$ mkdir build && cd build
host$ PATH+=/opt/arm-sysmic-linux-uclibcgnueabi/usr/bin
host$ ../configure --host=arm-linux --build=i386
\end{lstlisting} %$
  \item Compilation
\begin{lstlisting}
host$ make
\end{lstlisting} %$
  \item Installation
\begin{lstlisting}
host$ make DESTDIR=~/rootfs install
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler avec autotools}
  Obtenir de l'aide:
\begin{lstlisting}
host$ ./configure --help
\end{lstlisting} %$

  Parmis les fichiers générés:
  \begin{itemize}
  \item \file{config.log}  contient la sortie  des opérations effectuées
    lors de l'appel de \cmd{./configure}.  En particulier, il contient
    la ligne de commande utilisée. Il est ainsi possible de facilement
    dupliquer la configuration.
\begin{lstlisting}
host$ head config.log
\end{lstlisting} %$
  \item     \cmd{config.status}     permet     de    regénérer     les
    Makefile.  \cmd{config.status} est  automatiquement appellé  si un
    Makefile.am est modifié.
  \end{itemize}
\end{frame}

% TODO: cmake

\subsection{Kmake}

\begin{frame}[fragile=singleslide]{Compiler un programme tiers}{Kconfig}
  \begin{itemize}
  \item Système de compilation du noyau
  \item Très bien adapté à la cross-compilation
  \item Adapté aux environnements embarqués
  \item Adapté aux environnements avec beaucoup de configuration
  \item  Pas un  système de  compilation réel. Composé de :
    \begin{itemize}
    \item Kconfig, Système de gestion de configuration
    \item  Kmake, règles  Makefile  bien étudiées.  Chaque projet  les
      adapte à ces besoins
    \end{itemize}
  \item Application de la règle: "Pas générique mais simple à hacker"
  \item Dépend principalement de \cmd{gmake}
  \item Exemple avec busybox:
    \begin{lstlisting}
host$ wget http://busybox.net/downloads/busybox-1.23.2.tar.bz2
host$ tar xvjf busybox-1.23.2.tar.bz2
host$ cd busybox-1.23.2
host$ make help
    \end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler un programme tiers}{Kconfig}
  \begin{itemize}
  \item Pour configurer les options:
    \begin{itemize}
    \item En ncurses (2 versions)
\begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make menuconfig
host$ make nconfig
\end{lstlisting} %$
    \item En Qt4
\begin{lstlisting}
host% apt-get install libqt4-dev
host$ make xconfig
\end{lstlisting} %$
    \end{itemize}
  \item Permettent d'effectuer des recherches
  \item Ne pas oublier d'installer les headers des bibliothèques
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler un programme tiers}{Kconfig}
  \begin{itemize}
  \item Pour cross-compiler
\begin{lstlisting}
host$ make
\end{lstlisting} %$
  \item Pour compiler \emph{out-of-source}
\begin{lstlisting}
host$ mkdir build
host$ make O=build
\end{lstlisting} %$
  \item Mode verbose: \cmd{V=1}
  \item Forcer la toolchain: \cmd{CROSS_COMPILE=arm-linux-}
  \item Indispensable pour le noyau: \cmd{ARCH=arm}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Compiler un programme tiers}{Kconfig}
  Test avec busybox:
  \begin{itemize}
  \item Récupération d'une configuration par défaut
\begin{lstlisting}
host$ make CROSS_COMPILE=arm-linux- O=build defconfig
\end{lstlisting} %$
  \item Personnalisation de la configuration
\begin{lstlisting}
host% apt-get install libncurses5-dev
host$ make CROSS_COMPILE=arm-linux- O=build menuconfig
\end{lstlisting} %$
  \item Compilation
\begin{lstlisting}
host$ make CROSS_COMPILE=arm-linux-
\end{lstlisting} %$
  \item Installation
\begin{lstlisting}
host$ make CROSS_COMPILE=arm-linux- CONFIG_PREFIX=~/rootfs install
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}{Compiler un programme tiers}{Placement des bibliothèques}
  \begin{itemize}
  \item Pour que les autres programmes puissent en profiter le plus simple est
    d'installer les bibliothèques dans \cmd{TOOLCHAIN/TRIPLET/sysroot}. Elle
    seront ainsi trouvées automatiquement par le compilateur.
  \item Il est aussi possible de modifier les variables \cmd{CFLAGS} et
    \cmd{LDFLAGS} (plus complexe)
  \item Nous verrons que les bibliothèques doivent aussi se trouver sur la cible.
  \end{itemize}
\end{frame}

\subsection{En cas de problème}

\begin{frame}{Compiler un programme tiers}{Et si ca ne marche pas?}
  \begin{itemize}
  \item Cas où  des programmes doivent être compilés  puis exécutés sur la cible
    lors de la compilation
  \item Classiquement, des cas de bootstraping
  \item Cas  notable de Python\footnote{compile avec  des patchs, mais
      pas évident}
  \item Deux solutions:
    \begin{itemize}
    \item Résoudre le problème et envoyer un patch
    \item Compiler sur la target.
      \begin{itemize}
      \item Vous avez alors besoin d'un gcc natif sur la target
      \item Un émulateur type qemu peut vous aider
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}


\section{Ecrire un projet pour Linux embarqué}

\subsection{Avec les Autotools}

\begin{frame}[fragile=singleslide]{Historique des Autotools}
  \note[item]{Faire l'historique de configure/Makefile/autotools}
  \begin{enumerate}
  \item Makefile
  \item Makefile + hacks pour effectuer de la configuration
  \item Makefile.in + configure
  \item Makefile.in + configure.ac
  \item Makefile.am + configure.ac
  \end{enumerate}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet avec autotools}
  Fonctionnement des autotools:
  \begin{itemize}
  \item Préparation
\begin{lstlisting}
% apt-get install automake autoconf
\end{lstlisting}
  \item Déclaration de notre programme et de nos sources pour \cmd{automake}
\begin{lstlisting}
$ vim Makefile.am
\end{lstlisting} %$
\begin{lstlisting}
bin_PROGRAMS = hello
hello_SOURCES = hello.c hello.h
\end{lstlisting}
%  \item Les \cmd{autotools}  imposent l'existence de certains fichiers
%    de documentation
%\begin{lstlisting}
%$ touch NEWS README AUTHORS ChangeLog
%\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet avec autotools}
  \begin{itemize}
  \item  Création  d'un  template  pour \cmd{autoconf}  contenant  les
    macros utiles pour notre projet
\begin{lstlisting}
$ autoscan
$ mv configure.scan configure.ac
$ rm autoscan.log
$ vim configure.ac
\end{lstlisting}
  \item Personnalisation du résultat
\begin{lstlisting}
...
AC_INIT([hello], [1.0], [bug@sysmic.org])
AM_INIT_AUTOMAKE([foreign])
...
\end{lstlisting}
  \item      Génération      du      \file{configure}      et      des
    \file{Makefile.in}. C'est cette version qui devrait être livée aux
    packageurs.
\begin{lstlisting}
$ autoreconf -iv
\end{lstlisting} %$
    \note[item]{Bon, pas de TP la dessus, ca pas très utile}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet avec autotools}
  \begin{itemize}
  \item Compilation
\begin{lstlisting}
$ ./configure --help
$ mkdir build
$ cd build
$ ../configure --host=arm-linux --build=i386
$ make
$ make DESTDIR=~/rootfs install
\end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet avec autotools}
  La cible \verb+distcheck+ :
  \begin{enumerate}
  \item Recopie les fichiers référencés dans Autotools
  \item Retire les droits en écriture sur les sources
  \item Lance une compilation \emph{out-of-source}
  \item Installe le projet
  \item Lance la suite de test
  \item Lance un distclean
  \item Vérifie que tous les fichiers créés sont effectivement supprimés
  \item Crée une \emph{tarball} correctement nommée contenant les sources
  \end{enumerate}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet avec autotools}
  Si \cmd{automake}  est appelé avec  \verb+-gnits+, \verb+distcheck+
  effectue des vérifications supplémentaires sur la documentation,
  etc...
  \\[2ex]
  La fonctionnalité \verb+distcheck+ est  le point fort souvent énoncé
  des autotools.
\begin{lstlisting}
$ make distcheck
$ tar tvzf hello-1.0.tar.gz
\end{lstlisting} %$
\end{frame}

\subsection{Sans les Autotools}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  Utiliser les règles implicites facilite votre travail
  \lstinputlisting{samples/hello/Makefile.1}
  Testons:
\begin{lstlisting}
host$ make CC=arm-linux-gcc CFLAGS=-Wall
\end{lstlisting} %$
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  Les règles \c{default}, \c{clean}, \c{distclean} et \c{install} sont
  standards:
  \lstinputlisting{samples/hello/Makefile.2}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  \cmd{VPATH} vous permet de gérer la compilation \emph{out-of-source}.
  Remarquez que, pour que \verb+VPATH+ fonctionne correctement, il faut avoir
  correctement utilisé le quoting pour les directives d'inclusion (\verb+<+ pour
  les entêtes systèmes et \verb+"+ pour les entêtes du projet).
  % Pas besoin d'ajouter VPATH = . Du coup, c'est la meme chose que Makefile.1
  %\lstinputlisting{samples/hello/Makefile.2}

  Testons:
\begin{lstlisting}
host$ cd build
host$ make -f ../Makefile VPATH=.. CC=arm-linux-gcc
\end{lstlisting} %$
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  \cmd{gcc} peut  générer les dépendances de vos  fichiers.  On génère
  ainsi  des morceaux  de Makefile  que l'on  inclue. Il  ne  faut pas
  oublier   d'ajouter  la  dépendance   entre  \cmd{hello.d}   et  les
  dépendances de \cmd{hello.c}
  \lstinputlisting{samples/hello/Makefile.3}
  \note{ Voir http://www.makelinux.net/make3/make3-CHP-2-SECT-7.html}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  Les  Makefile permettent d'utiliser  des fonctions  de substitutions
  qui  peuvent  nous aider  à  rendre  notre  système plus  générique.
  \lstinputlisting{samples/hello/Makefile.4}
\end{frame}

\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  Nous pouvons  ajouter des alias  pour nous aider dans  les commandes
  complexes
  \lstinputlisting[firstline=19]{samples/hello/Makefile.5}
  \note[item]{TODO: Ajouter des \#ifdef CONFIG pour faire dans Kconfig}
  \note[item]{Parler de apt-get source (-b), dpkg -L, dpkg -l, dpkg-buildpackage}
\end{frame}


\begin{frame}[fragile=singleslide]{Créer un projet sans autotools}
  En poussant ce fonctionnement un peu plus loin, on obtient le Kmake.\\
  Un système  génère un fichier contenant toutes  les options.  Kmake,
  utilise des variables pour rendre la compilation conditionnelle:
\begin{lstlisting}
HELLO_$(CONFIG1) += hello.o
\end{lstlisting}
  Néanmoins,  le résultat  n'est  pas portable  entre les  différentes
  implémentations de \cmd{make}.
\end{frame}

\section{Bibliothèques courantes}

\begin{frame}[fragile=singleslide]{Bibliothèques courantes}
  Il existe  des milliers de  bibliothèques et d'API  disponibles pour
  Linux. Parmi elles:
  \begin{itemize}
  \item Les  appels systèmes. Inclus  avec le noyau  Linux. Documentés
    par les pages de man. Liste sur \man{syscalls(2)}
  \item L'interface  Posix.  Fournis par la libc.   Documentés par les
    pages    de   man   des    sections   3    ou   3posix    ou   sur
    \url{http://www.unix.org/version3/}
  \item Les bibliothèques très  utilisées: libapr, glib, ømq, ...  La
    documentation se trouve avec les source ou sur leur site web.
  \item Qt.  Bibliothèque très complète pouvant être  utilisé pour des
    usage    très   divers:    embarqué,    multimédia,   etc...    En
    C++. Documentation sur \url{http://qt-project.org/doc/qt-5.0}
  \item  Regarder  les packets  inclus  dans  Buildroot  ou sur  votre
    distribution permet  d'avoir une  idée des bibliothèques  les plus
    courantes
  \end{itemize}
\end{frame}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
